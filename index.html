<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TURBO DRIFT: ULTIMATE</title>
    <style>
        :root { --neon: #00f3ff; --danger: #ff0055; --bg: #0a0a12; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; user-select: none; color: white; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        
        /* TOP HUD */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .card { pointer-events: auto; background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2); padding: 10px 20px; border-radius: 8px; backdrop-filter: blur(10px); display: flex; gap: 15px; align-items: center; }
        .money { font-size: 24px; font-weight: 900; color: #fff; }
        .money span { color: var(--neon); }
        .stat-label { font-size: 12px; color: #aaa; font-weight: bold; margin-bottom: -5px; }
        
        button { background: var(--danger); border: none; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold; cursor: pointer; text-transform: uppercase; }
        button:hover { filter: brightness(1.2); }

        /* RACE UI */
        #race-panel { text-align: center; position: absolute; top: 80px; left: 50%; transform: translateX(-50%); }
        #lap-counter { font-size: 40px; font-weight: 900; font-style: italic; text-shadow: 0 0 10px black; display: none; }
        #join-btn { padding: 15px 40px; font-size: 20px; background: linear-gradient(45deg, #ff8800, #ff4400); animation: pulse 2s infinite; pointer-events: auto; }
        
        /* NOTIFICATIONS */
        #msg-area { position: absolute; top: 200px; width: 100%; text-align: center; pointer-events: none; }
        .msg { display: inline-block; background: rgba(0,0,0,0.8); padding: 10px 30px; border-radius: 20px; border: 1px solid var(--neon); margin-bottom: 5px; font-weight: bold; animation: fade 4s forwards; }

        /* BOTTOM HUD */
        .hud-bot { display: flex; justify-content: space-between; align-items: flex-end; }
        .speedo { text-align: right; }
        .speed-val { font-size: 80px; font-weight: 900; line-height: 0.8; font-style: italic; }
        .bar-bg { width: 300px; height: 10px; background: #333; margin-top: 10px; border-radius: 5px; }
        .bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--neon), var(--danger)); transition: width 0.1s; }
        .controls { color: #888; font-size: 12px; }
        
        /* SHOP */
        #shop { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 99; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; max-width: 800px; }
        .item { border: 1px solid #444; padding: 20px; border-radius: 10px; text-align: center; }
        .item:hover { border-color: var(--neon); background: rgba(255,255,255,0.05); }

        #respawn-btn { pointer-events: auto; display: none; background: #333; border: 1px solid #666; position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        @keyframes fade { 0% { opacity: 0; transform: translateY(20px); } 10% { opacity: 1; transform: translateY(0); } 90% { opacity: 1; } 100% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="card">
                <div class="money"><span>$</span><span id="cash">0</span></div>
                <button onclick="Game.toggleShop()">Garage</button>
            </div>
            <div class="card">
                <div>
                    <div class="stat-label">PLAYERS ONLINE</div>
                    <div class="money" id="p-count">1</div>
                </div>
            </div>
        </div>

        <div id="race-panel">
            <button id="join-btn" onclick="Game.joinRace()">JOIN RACE (2 Players Req)</button>
            <div id="lap-counter">LAP <span id="lap-val">1</span> / 5</div>
        </div>

        <div id="msg-area"></div>
        <button id="respawn-btn" onclick="Game.respawn()">RESPAWN (R)</button>

        <div class="hud-bot">
            <div class="controls">ARROWS: Drive | SHIFT: Drift | R: Respawn | C: Camera</div>
            <div class="speedo">
                <div class="speed-val" id="speed">0</div>
                <div style="color:var(--neon); font-weight:bold; letter-spacing:2px;">KM/H</div>
                <div class="bar-bg"><div class="bar-fill" id="rpm"></div></div>
            </div>
        </div>
    </div>

    <div id="shop">
        <h1 style="font-size:40px; margin-bottom:40px;">DEALERSHIP</h1>
        <div class="grid" id="shop-grid"></div>
        <button onclick="Game.toggleShop()" style="margin-top:30px; background:transparent; border:1px solid #666;">CLOSE</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // --- PHYSICS CLASS ---
        class Car {
            constructor(stats, color) {
                this.stats = stats;
                this.mesh = this.createMesh(color);
                
                // Physics Vectors
                this.pos = new THREE.Vector3(130, 2, 0); 
                this.velocity = new THREE.Vector3(); // Real movement vector
                this.quat = new THREE.Quaternion();
                
                this.speed = 0; // Engine power scalar
                this.rotVel = 0;
                
                // Game State
                this.checkpoint = 0;
                this.lap = 1;
                this.lastSafePos = new THREE.Vector3(130, 2, 0);
            }

            createMesh(color) {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.6 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 4.4), mat);
                body.position.y = 0.6;
                body.castShadow = true;
                g.add(body);
                
                const wGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
                const wMat = new THREE.MeshLambertMaterial({ color: 0x222 });
                const pos = [{x:1.1, z:1.2}, {x:-1.1, z:1.2}, {x:1.1, z:-1.4}, {x:-1.1, z:-1.4}];
                this.wheels = [];
                pos.forEach(p => {
                    const w = new THREE.Mesh(wGeo, wMat);
                    w.rotation.z = Math.PI/2;
                    w.position.set(p.x, 0.4, p.z);
                    w.castShadow = true;
                    g.add(w);
                    this.wheels.push(w);
                });
                return g;
            }

            update(inputs, dt, terrainFn) {
                // 1. Terrain Height
                const h = terrainFn(this.pos.x, this.pos.z);
                
                // 2. Acceleration
                let accel = 0;
                if(inputs.ArrowUp) accel = this.stats.accel;
                if(inputs.ArrowDown) accel = -this.stats.accel;
                
                this.speed += accel;
                this.speed *= 0.98; // Drag

                // 3. Steering (Sharper now)
                if(Math.abs(this.speed) > 0.1) {
                    const dir = this.speed > 0 ? 1 : -1;
                    // Boost turn speed
                    const turnForce = this.stats.turn * 1.5; 
                    if(inputs.ArrowLeft) this.rotVel += turnForce * dt * dir;
                    if(inputs.ArrowRight) this.rotVel -= turnForce * dt * dir;
                }
                this.rotVel *= 0.9;
                
                const q = new THREE.Quaternion();
                q.setFromAxisAngle(new THREE.Vector3(0,1,0), this.rotVel);
                this.quat.multiply(q).normalize();

                // 4. Drift Physics (Sliding)
                const fwd = new THREE.Vector3(0,0,1).applyQuaternion(this.quat);
                
                // If Shift held, reduce grip (slide)
                const grip = inputs.Shift ? 0.05 : 0.3;
                
                // Target velocity is where the nose points
                const targetVel = fwd.clone().multiplyScalar(this.speed);
                
                // Smoothly blend current velocity to target velocity (Simulates inertia/slide)
                this.velocity.lerp(targetVel, grip);

                // 5. Apply Movement
                this.pos.add(this.velocity);
                this.pos.y = h + 0.5;

                // 6. Barrier Collision
                const dist = Math.sqrt(this.pos.x*this.pos.x + this.pos.z*this.pos.z);
                const inRing = (dist > 105 && dist < 155);
                const inLobby = (Math.abs(this.pos.x - 130) < 20 && Math.abs(this.pos.z) < 20);

                if(!inRing && !inLobby && Game.racing) {
                    this.speed *= -0.5; // Bounce
                    this.velocity.multiplyScalar(-0.5);
                    // Push back
                    const angle = Math.atan2(this.pos.z, this.pos.x);
                    const targetDist = dist > 155 ? 154 : 106;
                    this.pos.x = Math.cos(angle) * targetDist;
                    this.pos.z = Math.sin(angle) * targetDist;
                }

                // 7. Visuals
                this.mesh.position.copy(this.pos);
                this.mesh.quaternion.copy(this.quat);
                this.wheels.forEach(w => w.rotation.x += this.speed);
                this.mesh.children[0].rotation.z = -this.rotVel * 4;
                this.mesh.children[0].rotation.x = -this.speed * 0.05;

                // 8. Particle Emitter for Drift
                if(inputs.Shift && Math.abs(this.speed) > 0.5) {
                    Game.emitSmoke(this.pos);
                }
            }
        }

        // --- MAIN GAME ---
        const Game = {
            socket: null,
            scene: null, camera: null, renderer: null,
            input: { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, Shift:false },
            players: {},
            myCar: null,
            racing: false,
            camIndex: 0,
            
            init() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a12);
                this.scene.fog = new THREE.FogExp2(0x0a0a12, 0.005);
                
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(hemi);
                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(100, 200, 50);
                sun.castShadow = true;
                this.scene.add(sun);

                this.buildWorld();
                this.setupInputs();
                this.connect();

                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },

            buildWorld() {
                this.simplex = new SimplexNoise();
                
                // Terrain
                const geo = new THREE.PlaneGeometry(800, 800, 100, 100);
                const pos = geo.attributes.position;
                for(let i=0; i<pos.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i);
                    pos.setZ(i, this.getHeight(x, -y));
                }
                geo.computeVertexNormals();
                const mat = new THREE.MeshStandardMaterial({ color: 0x1a1a24, roughness: 0.8 });
                const terrain = new THREE.Mesh(geo, mat);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;
                this.scene.add(terrain);

                // Track
                const tGeo = new THREE.RingGeometry(105, 155, 128);
                const tMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const track = new THREE.Mesh(tGeo, tMat);
                track.rotation.x = -Math.PI/2;
                track.position.y = 0.6;
                track.receiveShadow = true;
                this.scene.add(track);
                
                // Neon Barriers
                const outer = new THREE.Mesh(new THREE.TorusGeometry(155, 0.5, 16, 128), new THREE.MeshBasicMaterial({color:0xff0055}));
                outer.rotation.x = Math.PI/2; outer.position.y = 1;
                this.scene.add(outer);
                
                const inner = new THREE.Mesh(new THREE.TorusGeometry(105, 0.5, 16, 128), new THREE.MeshBasicMaterial({color:0xff0055}));
                inner.rotation.x = Math.PI/2; inner.position.y = 1;
                this.scene.add(inner);
            },

            getHeight(x, z) {
                const d = Math.sqrt(x*x + z*z);
                if(d > 100 && d < 160) return 0;
                return Math.max(0, this.simplex.noise2D(x*0.01, z*0.01) * 10);
            },

            spawnMe(carId) {
                if(this.myCar) this.scene.remove(this.myCar.mesh);
                const colors = [0x3366ff, 0xff3333, 0xffaa00, 0xcc00ff];
                const stats = [
                    {accel:0.02, turn:0.04}, 
                    {accel:0.03, turn:0.045}, 
                    {accel:0.04, turn:0.035}, 
                    {accel:0.06, turn:0.05}
                ];
                this.myCar = new Car(stats[carId], colors[carId]);
                this.scene.add(this.myCar.mesh);
            },

            connect() {
                this.socket = io();
                this.socket.on('welcome', d => {
                    this.myId = d.id;
                    this.shopData = d.shop;
                    this.economy = {money: d.list[this.myId].money, owned: d.list[this.myId].owned};
                    document.getElementById('cash').innerText = this.economy.money;
                    this.spawnMe(d.list[this.myId].carId);
                    Object.values(d.list).forEach(p => { if(p.id!==this.myId) this.spawnOther(p); });
                });

                this.socket.on('playerJoin', p => this.spawnOther(p));
                this.socket.on('countUpdate', c => document.getElementById('p-count').innerText = c);
                
                this.socket.on('playerUpdate', p => {
                    if(this.players[p.id]) {
                        const m = this.players[p.id].mesh;
                        m.position.lerp(new THREE.Vector3(p.x, p.y, p.z), 0.3);
                        m.quaternion.slerp(new THREE.Quaternion(p.qx, p.qy, p.qz, p.qw), 0.3);
                    }
                });
                
                this.socket.on('playerLeave', id => {
                    if(this.players[id]) { this.scene.remove(this.players[id].mesh); delete this.players[id]; }
                });

                this.socket.on('serverMsg', msg => this.notify(msg));
                this.socket.on('economyUpdate', d => {
                    this.economy.money = d.money;
                    this.economy.owned = d.owned;
                    document.getElementById('cash').innerText = d.money;
                    if(d.car !== undefined) this.spawnMe(d.car);
                });

                this.socket.on('raceStart', (data) => {
                    this.racing = true;
                    this.myCar.speed = 0;
                    this.myCar.lap = 1;
                    this.myCar.checkpoint = 0;
                    this.myCar.velocity.set(0,0,0);
                    
                    const pos = data.grid[this.myId];
                    if(pos) {
                        this.myCar.pos.set(pos.x, 2, pos.z);
                        this.myCar.rotVel = 0;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
                        this.myCar.quat = q;
                        this.myCar.lastSafePos.copy(this.myCar.pos);
                    }

                    document.getElementById('join-btn').style.display = 'none';
                    document.getElementById('lap-counter').style.display = 'block';
                    document.getElementById('respawn-btn').style.display = 'block';
                    this.notify("ðŸŸ¢ GO! GO! GO!");
                });
            },

            spawnOther(p) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(2,0.6,4.4), new THREE.MeshStandardMaterial({color:p.color||0xffffff}));
                body.position.y = 0.6;
                group.add(body);
                group.position.set(p.x, p.y, p.z);
                this.scene.add(group);
                this.players[p.id] = {mesh:group};
            },

            setupInputs() {
                document.addEventListener('keydown', e => {
                    this.input[e.key] = true;
                    // Fix: Check for Shift
                    if(e.key === "Shift") this.input.Shift = true;
                });
                document.addEventListener('keyup', e => {
                    this.input[e.key] = false;
                    if(e.key === "Shift") this.input.Shift = false;
                    
                    if(e.key.toLowerCase() === 'r') this.respawn();
                    if(e.key.toLowerCase() === 'c') {
                        this.camIndex = (this.camIndex + 1) % 3;
                    }
                });
            },

            respawn() {
                if(!this.racing) return;
                this.myCar.pos.copy(this.myCar.lastSafePos);
                this.myCar.pos.y += 3;
                this.myCar.speed = 0;
                this.myCar.velocity.set(0,0,0);
                this.myCar.rotVel = 0;
                this.myCar.quat.set(0,0,0,1);
            },

            emitSmoke(pos) {
                if(!this.smoke) this.smoke = [];
                const g = new THREE.BoxGeometry(0.3,0.3,0.3);
                const m = new THREE.MeshBasicMaterial({color:0xaaaaaa, transparent:true, opacity:0.6});
                const mesh = new THREE.Mesh(g,m);
                mesh.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5),0,(Math.random()-0.5)));
                this.scene.add(mesh);
                this.smoke.push({m:mesh, life:1.0});
            },

            joinRace() { this.socket.emit('joinRace'); },
            
            checkLaps() {
                if(!this.racing) return;
                const pos = this.myCar.pos;
                const angle = Math.atan2(pos.z, pos.x);
                
                let region = -1;
                if(Math.abs(angle - Math.PI) < 0.5 || Math.abs(angle + Math.PI) < 0.5) region = 0;
                else if(Math.abs(angle + Math.PI/2) < 0.5) region = 1;
                else if(Math.abs(angle) < 0.5) region = 2;
                else if(Math.abs(angle - Math.PI/2) < 0.5) region = 3;

                const cp = this.myCar.checkpoint;
                if(region === (cp + 1) % 4) {
                    this.myCar.checkpoint = region;
                    this.myCar.lastSafePos.copy(this.myCar.pos);
                    
                    if(region === 0 && cp === 3) {
                        this.myCar.lap++;
                        document.getElementById('lap-val').innerText = Math.min(this.myCar.lap, 5);
                        this.socket.emit('lapComplete', this.myCar.lap);
                        if(this.myCar.lap > 5) {
                            this.racing = false;
                            this.notify("RACE FINISHED!");
                        }
                    }
                }
            },

            updateCam() {
                // Modes: 0=Follow, 1=Far, 2=Top
                let offset;
                if(this.camIndex === 0) offset = new THREE.Vector3(0, 8, -18);
                else if(this.camIndex === 1) offset = new THREE.Vector3(0, 20, -40);
                else offset = new THREE.Vector3(0, 80, 0);

                offset.applyQuaternion(this.myCar.quat);
                const target = this.myCar.pos.clone().add(offset);
                this.camera.position.lerp(target, 0.1);
                this.camera.lookAt(this.myCar.pos);
            },

            animate() {
                requestAnimationFrame(this.animate);
                if(this.myCar) {
                    const hFn = (x,z) => this.getHeight(x,z);
                    this.myCar.update(this.input, 0.016, hFn);
                    this.checkLaps();
                    this.updateCam();

                    document.getElementById('speed').innerText = Math.floor(Math.abs(this.myCar.speed) * 120);
                    document.getElementById('rpm').style.width = Math.abs(this.myCar.speed)*50 + "%";

                    this.socket.emit('move', {
                        x: this.myCar.pos.x, y: this.myCar.pos.y, z: this.myCar.pos.z,
                        qx: this.myCar.quat.x, qy: this.myCar.quat.y, qz: this.myCar.quat.z, qw: this.myCar.quat.w
                    });
                }
                
                // Smoke
                if(this.smoke) {
                    for(let i=this.smoke.length-1; i>=0; i--) {
                        let p = this.smoke[i];
                        p.life -= 0.02;
                        p.m.position.y += 0.05;
                        p.m.material.opacity = p.life * 0.5;
                        if(p.life <= 0) { this.scene.remove(p.m); this.smoke.splice(i,1); }
                    }
                }

                this.renderer.render(this.scene, this.camera);
            },

            notify(msg) {
                const d = document.createElement('div');
                d.className = 'msg'; d.innerText = msg;
                document.getElementById('msg-area').appendChild(d);
                setTimeout(() => d.remove(), 4000);
            },

            toggleShop() {
                const s = document.getElementById('shop');
                s.style.display = s.style.display==='flex'?'none':'flex';
                if(s.style.display==='flex') {
                    const g = document.getElementById('shop-grid');
                    g.innerHTML = '';
                    Object.values(this.shopData).forEach((item, id) => {
                        const div = document.createElement('div');
                        div.className = 'item';
                        const owned = this.economy.owned.includes(parseInt(id));
                        div.innerHTML = `<h3>${item.name}</h3><p>Price: $${item.price}</p><button onclick="Game.socket.emit('${owned?'equip':'buy'}', ${id})">${owned?'EQUIP':'BUY'}</button>`;
                        g.appendChild(div);
                    });
                }
            }
        };

        window.onload = () => Game.init();
    </script>
</body>
</html>
