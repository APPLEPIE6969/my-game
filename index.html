<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURBO DRIFT: ULTIMATE EDITION</title>
    <style>
        /* =========================================
           CSS STYLES - UI & HUD
           ========================================= */
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #bc13fe;
            --neon-red: #ff0055;
            --glass: rgba(10, 10, 16, 0.85);
            --border: 1px solid rgba(255, 255, 255, 0.15);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* --- HUD LAYOUT --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* TOP BAR */
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px 40px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .profile-card {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: var(--border);
            padding: 15px 30px;
            border-radius: 8px;
            display: flex;
            gap: 20px;
            align-items: center;
            transform: skewX(-15deg);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .currency {
            font-size: 24px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px var(--neon-blue);
        }
        
        .currency span { color: var(--neon-blue); margin-right: 5px; }

        .btn-garage {
            background: var(--neon-red);
            border: none;
            color: white;
            font-weight: 800;
            text-transform: uppercase;
            padding: 10px 20px;
            cursor: pointer;
            transform: skewX(15deg); /* Counter skew */
            transition: 0.2s;
        }
        .btn-garage:hover { background: #ff4081; box-shadow: 0 0 15px var(--neon-red); }

        /* MINIMAP */
        #minimap-container {
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
            transform: skewX(-5deg);
        }
        #minimap-canvas { width: 100%; height: 100%; object-fit: contain; opacity: 0.8; }
        .map-dot { position: absolute; width: 6px; height: 6px; border-radius: 50%; transform: translate(-50%, -50%); }

        /* BOTTOM DASHBOARD */
        .hud-bottom {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 30px 50px;
        }

        .controls-hint {
            color: rgba(255,255,255,0.4);
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* SPEEDOMETER */
        .tacho-cluster {
            text-align: right;
            position: relative;
        }

        .gear-display {
            font-size: 120px;
            font-weight: 900;
            color: rgba(255,255,255,0.1);
            position: absolute;
            right: 120px;
            bottom: 20px;
            z-index: -1;
        }

        .speed-readout {
            font-size: 80px;
            font-weight: 900;
            font-style: italic;
            line-height: 1;
            text-shadow: 5px 5px 0px rgba(0,0,0,0.5);
        }

        .speed-unit {
            font-size: 20px;
            color: var(--neon-blue);
            font-weight: bold;
            letter-spacing: 4px;
        }

        .rpm-container {
            width: 400px;
            height: 12px;
            background: #222;
            border-radius: 6px;
            margin-top: 10px;
            overflow: hidden;
            border: 1px solid #444;
        }

        .rpm-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00f3ff, #00ff00, #ff0055);
            transition: width 0.05s linear;
        }

        /* SHOP MODAL */
        #shop-modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
            z-index: 100;
            pointer-events: auto;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            max-width: 1000px;
        }

        .car-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            transition: 0.3s;
        }
        .car-card:hover {
            border-color: var(--neon-blue);
            transform: translateY(-5px);
            background: rgba(255,255,255,0.1);
        }

        .btn-buy {
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            background: transparent;
            border: 2px solid white;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
        }
        .btn-buy:hover { background: white; color: black; }
        .owned { background: var(--neon-blue); border-color: var(--neon-blue); color: black; }
        
        /* NOTIFICATIONS */
        #notif-container {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }
        .notif {
            display: inline-block;
            background: rgba(0,0,0,0.8);
            border: 1px solid var(--neon-blue);
            padding: 15px 40px;
            border-radius: 50px;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 20px var(--neon-blue);
            animation: popIn 3s forwards;
        }

        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.8); }
            10% { opacity: 1; transform: scale(1.1); }
            20% { transform: scale(1); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
    </style>
</head>
<body>

    <!-- HUD LAYER -->
    <div id="ui-layer">
        
        <!-- TOP HUD -->
        <div class="hud-top">
            <div class="profile-card">
                <div class="currency"><span>$</span><span id="ui-money">0</span></div>
                <button class="btn-garage" onclick="Game.toggleShop()">Garage</button>
            </div>
            
            <div id="minimap-container">
                <canvas id="minimap-canvas" width="200" height="200"></canvas>
            </div>
        </div>

        <div id="notif-container"></div>

        <!-- BOTTOM HUD -->
        <div class="hud-bottom">
            <div class="controls-hint">
                Arrow Keys to Drive<br>Spacebar to Handbrake<br>C to Change Camera
            </div>

            <div class="tacho-cluster">
                <div class="gear-display" id="ui-gear">N</div>
                <div class="speed-readout"><span id="ui-speed">0</span></div>
                <div class="speed-unit">KM/H</div>
                <div class="rpm-container">
                    <div class="rpm-bar" id="ui-rpm"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- SHOP MODAL -->
    <div id="shop-modal">
        <h1 style="font-size: 50px; margin-bottom: 40px; text-shadow: 0 0 20px white;">DEALERSHIP</h1>
        <div class="shop-grid" id="shop-grid">
            <!-- CARDS GENERATED BY JS -->
        </div>
        <button onclick="Game.toggleShop()" style="margin-top: 50px; background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">CLOSE</button>
    </div>

    <!-- SCRIPTS -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Simplex Noise for Terrain -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        /**
         * =========================================================
         *  üîä AUDIO SYNTHESIZER
         *  Procedural Engine Sound Generator
         * =========================================================
         */
        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.2;
                this.master.connect(this.ctx.destination);
                
                this.osc = null;
                this.lfo = null;
                this.active = false;
            }

            init() {
                if(this.active) return;
                this.ctx.resume();

                // Main Engine Tone (Sawtooth)
                this.osc = this.ctx.createOscillator();
                this.osc.type = 'sawtooth';
                this.osc.frequency.value = 50;

                // Rumble (LFO)
                this.lfo = this.ctx.createOscillator();
                this.lfo.type = 'square';
                this.lfo.frequency.value = 30;

                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 200;

                this.lfo.connect(lfoGain);
                lfoGain.connect(this.osc.frequency);

                this.osc.connect(this.master);
                
                this.osc.start();
                this.lfo.start();
                this.active = true;
            }

            update(rpm) {
                if(!this.active) return;
                // Pitch modulation based on simulated RPM
                const baseFreq = 50 + (rpm * 400); 
                this.osc.frequency.setTargetAtTime(baseFreq, this.ctx.currentTime, 0.1);
                
                // Rumble speed
                this.lfo.frequency.value = 20 + (rpm * 50);
            }
        }

        /**
         * =========================================================
         *  üéÆ INPUT MANAGER
         *  Handles Keyboard State
         * =========================================================
         */
        class InputManager {
            constructor() {
                this.keys = {
                    ArrowUp: false,
                    ArrowDown: false,
                    ArrowLeft: false,
                    ArrowRight: false,
                    " ": false,
                    "c": false
                };
                
                document.addEventListener('keydown', (e) => this.onKey(e, true));
                document.addEventListener('keyup', (e) => this.onKey(e, false));
            }

            onKey(e, isDown) {
                if(this.keys.hasOwnProperty(e.key)) {
                    this.keys[e.key] = isDown;
                }
            }
        }

        /**
         * =========================================================
         *  üèéÔ∏è PHYSICS ENGINE (FIXED)
         *  Arcade-Style Speed with Raycast Suspension
         * =========================================================
         */
        class CarPhysics {
            constructor(startPos, color, stats) {
                this.pos = new THREE.Vector3(startPos.x, startPos.y, startPos.z);
                this.vel = new THREE.Vector3();
                this.speed = 0; // Scalar speed (Arcade Style)
                
                // Rotation (Quaternion)
                this.quat = new THREE.Quaternion();
                this.rotVelY = 0;

                this.rpm = 0;
                this.gear = 1;
                
                // Config
                this.stats = stats;
                this.chassisColor = color;
                this.mesh = this.createMesh(color);
                
                // Suspension Vars
                this.onGround = false;
            }

            createMesh(color) {
                const group = new THREE.Group();

                // Materials
                const paint = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.2 });
                const glass = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
                const rubber = new THREE.MeshLambertMaterial({ color: 0x222222 });

                // 1. Chassis Body (Tilting part)
                this.chassis = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.6, 4.4), paint);
                body.position.y = 0.6;
                body.castShadow = true;
                this.chassis.add(body);

                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.5, 2.2), glass);
                cabin.position.set(0, 1.15, -0.3);
                cabin.castShadow = true;
                this.chassis.add(cabin);

                group.add(this.chassis);

                // 2. Wheels (Attached to group, not chassis)
                const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
                const positions = [
                    {x: 1.1, z: 1.3}, {x: -1.1, z: 1.3}, // Rear
                    {x: 1.1, z: -1.4}, {x: -1.1, z: -1.4} // Front
                ];

                this.wheels = [];
                positions.forEach((p, i) => {
                    const w = new THREE.Mesh(wheelGeo, rubber);
                    w.rotation.z = Math.PI/2;
                    w.position.set(p.x, 0.4, p.z);
                    w.castShadow = true;
                    group.add(w);
                    this.wheels.push(w);
                });

                // 3. Lights
                const lightTarget = new THREE.Object3D();
                lightTarget.position.set(0, 0, -10);
                group.add(lightTarget);
                
                const spot = new THREE.SpotLight(0xffffff, 2, 60, 0.5, 0.5, 1);
                spot.position.set(0, 1, -1.8);
                spot.target = lightTarget;
                group.add(spot);

                return group;
            }

            update(inputs, terrainFn, dt) {
                // 1. Terrain Height Check
                const terrainH = terrainFn(this.pos.x, this.pos.z);
                const gravity = -25;
                
                // Simple Raycast Suspension
                if (this.pos.y < terrainH + 0.5) {
                    this.pos.y = terrainH + 0.5;
                    this.vel.y = 0;
                    this.onGround = true;
                } else {
                    this.vel.y += gravity * dt;
                    this.onGround = false;
                }

                // 2. ACCELERATION (Fixed Logic)
                if(this.onGround) {
                    if (inputs.keys.ArrowUp) this.speed += this.stats.accel; 
                    if (inputs.keys.ArrowDown) this.speed -= this.stats.accel;
                }

                // Friction
                this.speed *= 0.98;

                // 3. TURNING
                const turnSpeed = this.stats.turn;
                if (this.onGround && Math.abs(this.speed) > 0.1) {
                    const dir = this.speed > 0 ? 1 : -1;
                    if (inputs.keys.ArrowLeft) this.rotVelY += turnSpeed * dt * dir;
                    if (inputs.keys.ArrowRight) this.rotVelY -= turnSpeed * dt * dir;
                }
                this.rotVelY *= 0.9; // Damping

                // Apply Rotation
                const qRot = new THREE.Quaternion();
                qRot.setFromAxisAngle(new THREE.Vector3(0,1,0), this.rotVelY);
                this.quat.multiply(qRot);
                this.quat.normalize();

                // 4. APPLY VELOCITY
                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.quat);
                
                // Drift Logic
                const driftInput = inputs.keys[" "];
                // If drifting, we slide (keep velocity vector), if not, we follow nose
                // Note: Simplified for robustness
                
                this.vel.x = forward.x * this.speed;
                this.vel.z = forward.z * this.speed;

                this.pos.x += this.vel.x;
                this.pos.z += this.vel.z;
                this.pos.y += this.vel.y * dt;

                // 5. MESH UPDATES
                this.mesh.position.copy(this.pos);
                this.mesh.quaternion.copy(this.quat);

                // Visual Tilt
                const tiltX = this.speed * -0.002; // Pitch
                const tiltZ = -this.rotVelY * 5.0; // Roll
                
                // Interpolate Chassis Tilt
                this.chassis.rotation.x += (tiltX - this.chassis.rotation.x) * 0.1;
                this.chassis.rotation.z += (tiltZ - this.chassis.rotation.z) * 0.1;

                // Wheel Spin
                const wSpeed = this.speed * dt * 2;
                this.wheels.forEach(w => w.rotation.x += wSpeed);

                // RPM for UI
                const absSpeed = Math.abs(this.speed);
                const maxSpeed = 2.0; 
                this.rpm = (absSpeed % 0.5) / 0.5; 
                this.gear = Math.min(Math.floor(absSpeed / 0.4) + 1, 6);
            }
        }

        /**
         * =========================================================
         *  üåç WORLD MANAGER
         *  Procedural Terrain & Environment
         * =========================================================
         */
        class WorldManager {
            constructor(scene) {
                this.scene = scene;
                this.simplex = new SimplexNoise();
            }

            init() {
                // 1. Terrain Mesh
                const geometry = new THREE.PlaneGeometry(800, 800, 128, 128);
                const colors = [];
                const pos = geometry.attributes.position;
                
                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i);
                    const h = this.getHeight(x, -y); 
                    pos.setZ(i, h);

                    if(h < 2) colors.push(0.1, 0.5, 0.1); 
                    else if(h < 8) colors.push(0.3, 0.25, 0.2); 
                    else colors.push(0.5, 0.5, 0.5); 
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.computeVertexNormals();

                const material = new THREE.MeshStandardMaterial({ 
                    vertexColors: true, 
                    roughness: 0.8,
                    wireframe: false 
                });
                
                const terrain = new THREE.Mesh(geometry, material);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;
                this.scene.add(terrain);

                // 2. Water Plane
                const waterGeo = new THREE.PlaneGeometry(800, 800);
                const waterMat = new THREE.MeshPhongMaterial({ color: 0x0077ff, transparent: true, opacity: 0.6, shininess: 80 });
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.rotation.x = -Math.PI/2;
                water.position.y = 0.5; 
                this.scene.add(water);

                // 3. Track
                this.createTrack();
            }

            createTrack() {
                const trackGeo = new THREE.RingGeometry(110, 150, 128);
                const trackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
                const track = new THREE.Mesh(trackGeo, trackMat);
                track.rotation.x = -Math.PI/2;
                track.position.y = 1.0; 
                track.receiveShadow = true;
                this.scene.add(track);
            }

            getHeight(x, z) {
                let y = this.simplex.noise2D(x * 0.003, z * 0.003) * 15; 
                y += this.simplex.noise2D(x * 0.01, z * 0.01) * 2; 
                
                const dist = Math.sqrt(x*x + z*z);
                if(dist > 110 && dist < 150) {
                    y = THREE.MathUtils.lerp(y, 1.0, 0.8); 
                }
                return Math.max(y, -5);
            }
        }

        /**
         * =========================================================
         *  ‚ú® PARTICLE SYSTEM
         * =========================================================
         */
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                this.geometry = new THREE.DodecahedronGeometry(0.3); 
                this.material = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.5 });
            }

            emit(pos) {
                if(Math.random() > 0.3) return;
                const mesh = new THREE.Mesh(this.geometry, this.material);
                mesh.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5), 0.2, (Math.random()-0.5)));
                this.scene.add(mesh);
                this.particles.push({ mesh: mesh, life: 1.0, vel: new THREE.Vector3(0, 0.05, 0) });
            }

            update() {
                for(let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= 0.02;
                    p.mesh.position.add(p.vel);
                    p.mesh.scale.multiplyScalar(1.03); 
                    p.mesh.material.opacity = p.life * 0.5;
                    if(p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        /**
         * =========================================================
         *  üöÄ MAIN GAME CLASS
         * =========================================================
         */
        const Game = {
            socket: null,
            scene: null, camera: null, renderer: null,
            audio: new AudioController(),
            input: new InputManager(),
            world: null,
            particles: null,
            myId: null,
            players: {},
            myCar: null,
            shopData: {},
            economy: { money: 0, owned: [0] },
            dt: 0.016,

            init() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a12);
                this.scene.fog = new THREE.FogExp2(0x0a0a12, 0.005);

                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(130, 20, 0); 
                this.camera.lookAt(130, 0, 10);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(hemi);

                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(100, 200, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
                const d = 200;
                sun.shadow.camera.left = -d; sun.shadow.camera.right = d;
                sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
                this.scene.add(sun);

                this.world = new WorldManager(this.scene);
                this.world.init();
                
                this.particles = new ParticleSystem(this.scene);

                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('click', () => this.audio.init(), {once:true});

                this.connect();

                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            },

            connect() {
                this.socket = io();
                this.socket.on('initData', (data) => this.onWelcome(data));
                this.socket.on('welcome', (data) => this.onWelcome(data));
                this.socket.on('playerMoved', (p) => this.updateOtherCar(p));
                this.socket.on('playerUpdate', (p) => this.updateOtherCar(p));
                this.socket.on('newPlayer', (p) => this.spawnOther(p));
                this.socket.on('playerJoin', (p) => this.spawnOther(p));
                this.socket.on('updateEconomy', (d) => this.syncEconomy(d));
                this.socket.on('economyUpdate', (d) => this.syncEconomy(d));
                this.socket.on('disconnect', (id) => this.removePlayer(id));
                this.socket.on('playerLeave', (id) => this.removePlayer(id));
            },

            onWelcome(data) {
                this.myId = data.id;
                const playerData = data.players ? data.players[this.myId] : data.list[this.myId];
                this.shopData = data.shop;
                this.economy.money = playerData.money;
                this.economy.owned = playerData.ownedCars || playerData.owned;
                this.updateHUD();

                const carId = playerData.carType || playerData.carId || 0;
                this.spawnMe(carId);

                const list = data.players || data.list;
                Object.values(list).forEach(p => {
                    if(p.id !== this.myId) this.spawnOther(p);
                });
            },

            spawnMe(carId) {
                if(this.myCar) this.scene.remove(this.myCar.mesh);

                // FIXED STATS - Scaled for Direct Speed
                const statsMap = {
                    0: { accel: 0.02, turn: 3.5 },
                    1: { accel: 0.03, turn: 3.8 },
                    2: { accel: 0.045, turn: 3.2 },
                    3: { accel: 0.06, turn: 4.5 }
                };
                const colorMap = { 0: 0x3366ff, 1: 0xff3333, 2: 0xffaa00, 3: 0xcc00ff };
                
                const startPos = { x: 130, y: 5, z: 0 };
                this.myCar = new CarPhysics(startPos, colorMap[carId] || 0xffffff, statsMap[carId] || statsMap[0]);
                this.scene.add(this.myCar.mesh);
            },

            spawnOther(p) {
                if(this.players[p.id]) return;
                const color = p.color || 0xffffff;
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(2,0.6,4.4), new THREE.MeshStandardMaterial({color:color}));
                body.position.y = 0.6;
                group.add(body);
                const wGeo = new THREE.CylinderGeometry(0.4,0.4,0.4,12);
                const positions = [{x:1.1, z:1.2}, {x:-1.1, z:1.2}, {x:1.1, z:-1.4}, {x:-1.1, z:-1.4}];
                positions.forEach(pos => {
                    const w = new THREE.Mesh(wGeo, new THREE.MeshLambertMaterial({color:0x222}));
                    w.rotation.z = Math.PI/2;
                    w.position.set(pos.x, 0.4, pos.z);
                    group.add(w);
                });
                group.position.set(p.x, p.y || 1, p.z);
                this.scene.add(group);
                this.players[p.id] = { mesh: group };
            },

            updateOtherCar(p) {
                if(this.players[p.id]) {
                    const mesh = this.players[p.id].mesh;
                    mesh.position.lerp(new THREE.Vector3(p.x, p.y, p.z), 0.3);
                    if(p.qx) {
                        mesh.quaternion.slerp(new THREE.Quaternion(p.qx, p.qy, p.qz, p.qw), 0.3);
                    } else if (p.ry) {
                         let rotDiff = p.ry - mesh.rotation.y;
                        while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                        while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                        mesh.rotation.y += rotDiff * 0.2;
                    }
                }
            },

            removePlayer(id) {
                if(this.players[id]) {
                    this.scene.remove(this.players[id].mesh);
                    delete this.players[id];
                }
            },

            syncEconomy(d) {
                this.economy.money = d.money;
                this.economy.owned = d.owned;
                if(d.current || d.car) this.spawnMe(d.current || d.car);
                this.updateHUD();
                this.showNotification("TRANSACTION COMPLETE");
            },

            animate() {
                requestAnimationFrame(this.animate);
                if(this.myCar) {
                    const getH = (x, z) => this.world.getHeight(x, z);
                    this.myCar.update(this.input, getH, this.dt);
                    
                    const carPos = this.myCar.mesh.position;
                    const offset = new THREE.Vector3(0, 8, -18);
                    offset.applyQuaternion(this.myCar.quat);
                    const targetPos = carPos.clone().add(offset);
                    this.camera.position.lerp(targetPos, 0.1);
                    this.camera.lookAt(carPos);

                    this.audio.update(Math.abs(this.myCar.speed) / 2.0);
                    if(this.input.keys[" "] && Math.abs(this.myCar.speed) > 0.5) this.particles.emit(carPos);

                    const kmh = Math.floor(Math.abs(this.myCar.speed) * 120);
                    document.getElementById('ui-speed').innerText = kmh;
                    document.getElementById('ui-gear').innerText = this.myCar.gear;
                    document.getElementById('ui-rpm').style.width = (this.myCar.rpm * 100) + "%";
                    this.updateMinimap(carPos);

                    this.socket.emit('playerMovement', {
                        x: carPos.x, y: carPos.y, z: carPos.z,
                        qx: this.myCar.quat.x, qy: this.myCar.quat.y, qz: this.myCar.quat.z, qw: this.myCar.quat.w,
                        ry: this.myCar.mesh.rotation.y,
                        tilt: this.myCar.mesh.children[0].rotation.z 
                    });
                }
                this.particles.update();
                this.renderer.render(this.scene, this.camera);
            },

            updateHUD() { document.getElementById('ui-money').innerText = this.economy.money; },

            updateMinimap(pos) {
                const cvs = document.getElementById('minimap-canvas');
                const ctx = cvs.getContext('2d');
                ctx.clearRect(0,0,200,200);
                ctx.save();
                ctx.translate(100, 100);
                const scale = 0.2;
                ctx.fillStyle = "#00f3ff";
                ctx.beginPath();
                ctx.arc(pos.x * scale, pos.z * scale, 4, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = "#ff0055";
                Object.values(this.players).forEach(p => {
                    const m = p.mesh;
                    ctx.beginPath();
                    ctx.arc(m.position.x * scale, m.position.z * scale, 3, 0, Math.PI*2);
                    ctx.fill();
                });
                ctx.restore();
            },

            toggleShop() {
                const modal = document.getElementById('shop-modal');
                const grid = document.getElementById('shop-grid');
                if(modal.style.display === 'flex') {
                    modal.style.display = 'none';
                } else {
                    modal.style.display = 'flex';
                    grid.innerHTML = '';
                    const cars = [
                        {id:0, name:"ROOKIE KART", price:0, speed: 100},
                        {id:1, name:"STREET TUNER", price:500, speed: 140},
                        {id:2, name:"MUSCLE V8", price:1500, speed: 180},
                        {id:3, name:"F1 HYPERCAR", price:5000, speed: 250}
                    ];
                    cars.forEach(car => {
                        const owned = this.economy.owned.includes(car.id);
                        const btnText = owned ? "OWNED" : `BUY $${car.price}`;
                        const btnClass = owned ? "btn-buy owned" : "btn-buy";
                        const action = owned ? 
                            `Game.socket.emit('equipCar', ${car.id}); Game.socket.emit('equip', ${car.id});` : 
                            `Game.socket.emit('buyCar', ${car.id}); Game.socket.emit('buy', ${car.id});`;
                        grid.innerHTML += `
                        <div class="car-card">
                            <h2 style="margin:0">${car.name}</h2>
                            <h3 style="color:#00f3ff">TOP SPEED: ${car.speed} KM/H</h3>
                            <button class="${btnClass}" onclick="${action}">${btnText}</button>
                        </div>
                        `;
                    });
                }
            },

            showNotification(msg) {
                const el = document.createElement('div');
                el.className = 'notif';
                el.innerText = msg;
                document.getElementById('notif-container').appendChild(el);
                setTimeout(() => el.remove(), 3000);
            },

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        window.onload = () => Game.init();

    </script>
</body>
</html>
