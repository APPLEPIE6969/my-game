<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>APEX RACER LEGENDS</title>
    <style>
        :root { --primary: #00f2ff; --accent: #ff0055; --bg: #0a0a12; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', system-ui, sans-serif; user-select: none; }
        canvas { display: block; outline: none; }

        /* --- HUD LAYER --- */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        .panel { padding: 20px; text-transform: uppercase; letter-spacing: 1px; }
        
        /* Top Left: Money & Garage */
        #profile-ui { pointer-events: auto; display: flex; gap: 10px; align-items: center; }
        .badge { background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); padding: 10px 25px; border-radius: 4px; color: white; font-weight: 800; display: flex; align-items: center; box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: 0.2s; }
        .badge span { color: var(--primary); margin-right: 5px; font-size: 1.2em; }
        button.btn { background: var(--accent); border: none; color: white; padding: 10px 20px; border-radius: 4px; font-weight: bold; cursor: pointer; text-transform: uppercase; transition: transform 0.1s; }
        button.btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        button.btn:active { transform: scale(0.95); }

        /* Top Center: Race Status */
        #race-ui { text-align: center; opacity: 0; transition: opacity 0.5s; }
        .race-status-text { font-size: 40px; font-weight: 900; color: white; text-shadow: 0 0 20px var(--accent); font-style: italic; }
        #join-btn { pointer-events: auto; background: linear-gradient(45deg, #ff9900, #ff5500); padding: 15px 50px; font-size: 20px; margin-top: 10px; animation: pulse 2s infinite; }

        /* Bottom Right: Speedometer */
        #tacho-ui { text-align: right; margin-right: 20px; margin-bottom: 20px; position: relative; }
        #speed-num { font-size: 100px; font-weight: 900; color: white; line-height: 0.8; font-style: italic; text-shadow: 4px 4px 0px rgba(0,0,0,0.5); }
        #gear-label { font-size: 30px; color: var(--primary); font-weight: 800; }
        #rpm-bar { width: 300px; height: 10px; background: #333; margin-left: auto; border-radius: 5px; overflow: hidden; margin-top: 10px; }
        #rpm-fill { width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary), var(--accent)); transition: width 0.1s; }

        /* Bottom Left: Controls */
        #controls-ui { color: rgba(255,255,255,0.4); font-size: 12px; margin-left: 20px; margin-bottom: 20px; }

        /* --- SHOP OVERLAY --- */
        #shop-modal { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(15px); z-index: 100; align-items: center; justify-content: center; pointer-events: auto; }
        .shop-container { width: 80%; max-width: 1000px; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .car-card { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; text-align: center; transition: 0.3s; position: relative; overflow: hidden; }
        .car-card:hover { border-color: var(--primary); transform: translateY(-5px); background: rgba(255,255,255,0.1); }
        .car-name { color: white; font-weight: 800; font-size: 1.5em; margin-bottom: 10px; }
        .car-price { color: var(--primary); font-size: 1.2em; margin-bottom: 20px; }
        .stat-bar { background: #222; height: 6px; border-radius: 3px; margin: 10px 0; overflow: hidden; }
        .stat-fill { height: 100%; background: white; }

        /* --- NOTIFICATIONS --- */
        #notif-area { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
        .notif { background: rgba(0,0,0,0.7); color: white; padding: 10px 30px; border-radius: 30px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.2); animation: fadeUp 3s forwards; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        @keyframes fadeUp { 0% { opacity: 0; transform: translateY(20px); } 10% { opacity: 1; transform: translateY(0); } 90% { opacity: 1; } 100% { opacity: 0; transform: translateY(-20px); } }
    </style>
</head>
<body>

    <!-- HUD -->
    <div id="hud">
        <div class="panel" id="profile-ui">
            <div class="badge"><span>$</span><div id="money-val">0</div></div>
            <button class="btn" onclick="Game.toggleShop()">Garage</button>
        </div>

        <div class="panel" id="notif-area"></div>

        <div id="race-ui">
            <div class="race-status-text" id="race-text">RACE EVENT</div>
            <button id="join-btn" class="btn" onclick="Game.joinRace()">JOIN RACE ($500 PRIZE)</button>
        </div>

        <div style="flex-grow:1"></div> <!-- Spacer -->

        <div style="display: flex; justify-content: space-between; align-items: flex-end;">
            <div id="controls-ui">
                ARROWS to Drive â€¢ SPACE to Drift â€¢ C to Change Cam
            </div>
            <div id="tacho-ui">
                <div id="gear-label">N</div>
                <div id="speed-num">0</div>
                <div style="color:#aaa; font-weight:bold;">KM/H</div>
                <div id="rpm-bar"><div id="rpm-fill"></div></div>
            </div>
        </div>
    </div>

    <!-- SHOP -->
    <div id="shop-modal">
        <div class="shop-container" id="shop-grid">
            <!-- Items injected by JS -->
        </div>
        <button class="btn" onclick="Game.toggleShop()" style="position:absolute; top:30px; right:30px; background:transparent; border:2px solid white;">CLOSE</button>
    </div>

    <!-- LIBRARIES -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * ðŸŽµ AUDIO ENGINE
         * Synthesizes engine sounds using Web Audio API
         */
        class SoundEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.1; // Volume
                this.master.connect(this.ctx.destination);
                this.osc = null;
                this.mod = null;
                this.isRunning = false;
            }

            start() {
                if(this.isRunning) return;
                this.ctx.resume();
                
                // Main Engine Tone (Sawtooth for grit)
                this.osc = this.ctx.createOscillator();
                this.osc.type = 'sawtooth';
                this.osc.frequency.value = 60;

                // Modulation (Rumble)
                this.mod = this.ctx.createOscillator();
                this.mod.type = 'sine';
                this.mod.frequency.value = 30;
                
                const modGain = this.ctx.createGain();
                modGain.gain.value = 50;

                this.mod.connect(modGain);
                modGain.connect(this.osc.frequency);
                
                this.osc.connect(this.master);
                this.osc.start();
                this.mod.start();
                this.isRunning = true;
            }

            update(speedRatio) {
                if(!this.isRunning) return;
                // Pitch moves from 60Hz to 300Hz based on speed
                const targetFreq = 60 + (speedRatio * 250);
                this.osc.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1);
                
                // Rumble speed increases
                this.mod.frequency.value = 20 + (speedRatio * 50);
            }
        }

        /**
         * âœ¨ PARTICLE SYSTEM
         */
        class ParticleSystem {
            constructor(scene) {
                this.particles = [];
                this.scene = scene;
                this.geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                this.mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 });
            }

            emit(pos, count = 1) {
                for(let i=0; i<count; i++) {
                    const mesh = new THREE.Mesh(this.geo, this.mat);
                    // Random scatter
                    mesh.position.copy(pos).add(new THREE.Vector3(
                        (Math.random()-0.5)*1.5,
                        Math.random()*0.5,
                        (Math.random()-0.5)*1.5
                    ));
                    mesh.rotation.set(Math.random(), Math.random(), Math.random());
                    this.scene.add(mesh);
                    this.particles.push({ mesh, life: 1.0, vel: new THREE.Vector3(0, 0.1, 0) });
                }
            }

            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= 0.02;
                    p.mesh.position.add(p.vel);
                    p.mesh.rotation.x += 0.1;
                    p.mesh.scale.multiplyScalar(0.95);
                    p.mesh.material.opacity = p.life;
                    
                    if (p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        /**
         * ðŸš— GAME MANAGER
         */
        const Game = {
            socket: null,
            scene: null, camera: null, renderer: null,
            audio: new SoundEngine(),
            particles: null,
            
            // State
            myId: null,
            players: {},
            myCar: { mesh: null, speed: 0, steer: 0, type: 0 },
            economy: { money: 0, owned: [] },
            shopData: {},
            
            // Inputs
            keys: { ArrowUp:0, ArrowDown:0, ArrowLeft:0, ArrowRight:0, " ":0 },
            
            // Config
            config: { maxSpeed: 1.2, accel: 0.02, turn: 0.04 },

            init() {
                // Three.js Setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a12);
                this.scene.fog = new THREE.Fog(0x0a0a12, 50, 250);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                // Lighting
                const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(hemi);
                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(100, 200, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
                const d = 200;
                sun.shadow.camera.left = -d; sun.shadow.camera.right = d;
                sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
                this.scene.add(sun);

                // Systems
                this.particles = new ParticleSystem(this.scene);
                this.buildWorld();
                this.setupInputs();
                this.connect();

                // Start Loop
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
                
                // Start Audio on first click
                window.addEventListener('click', () => this.audio.start(), {once:true});
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },

            buildWorld() {
                // Ground Grid
                const texLoader = new THREE.TextureLoader();
                // Procedural Terrain Mesh
                const geo = new THREE.PlaneGeometry(800, 800, 100, 100);
                const pos = geo.attributes.position;
                
                // Custom pseudo-noise function to avoid external dependency
                const noise = (x, z) => Math.sin(x*0.02)*5 + Math.cos(z*0.015)*5 + Math.sin(x*0.05 + z*0.05)*2;

                for(let i=0; i<pos.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i); // Plane is XY initially
                    const h = noise(x, -y); 
                    pos.setZ(i, h > 0 ? h : 0); // clamp water
                }
                geo.computeVertexNormals();

                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a24, 
                    roughness: 0.8,
                    metalness: 0.2,
                    wireframe: false
                });
                
                const terrain = new THREE.Mesh(geo, mat);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;
                this.scene.add(terrain);

                // Grid Helper for "Tron" look
                const grid = new THREE.GridHelper(800, 100, 0x00f2ff, 0x111111);
                grid.position.y = 0.1;
                this.scene.add(grid);

                // Race Track (Glowing Ring)
                const trackGeo = new THREE.RingGeometry(95, 125, 128);
                const trackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 });
                const track = new THREE.Mesh(trackGeo, trackMat);
                track.rotation.x = -Math.PI / 2;
                track.position.y = 0.2;
                track.receiveShadow = true;
                this.scene.add(track);

                // Neon Borders
                const borderGeo = new THREE.TorusGeometry(125, 0.5, 16, 128);
                const borderMat = new THREE.MeshBasicMaterial({ color: 0xff0055 });
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.rotation.x = Math.PI / 2;
                border.position.y = 0.5;
                this.scene.add(border);
                
                const innerBorder = new THREE.Mesh(new THREE.TorusGeometry(95, 0.5, 16, 128), borderMat);
                innerBorder.rotation.x = Math.PI/2;
                innerBorder.position.y = 0.5;
                this.scene.add(innerBorder);
            },

            // --- CAR CREATION (High Detail) ---
            createCar(type, color) {
                const group = new THREE.Group();
                
                // Color preset based on upgrade level
                const bodyColor = [0x333333, 0x00f2ff, 0xff0055, 0xffaa00][type] || color;
                
                // 1. Body
                const chassisGeo = new THREE.BoxGeometry(2.2, 0.6, 4.4);
                const chassisMat = new THREE.MeshStandardMaterial({ color: bodyColor, metalness: 0.7, roughness: 0.1 });
                const chassis = new THREE.Mesh(chassisGeo, chassisMat);
                chassis.position.y = 0.7;
                chassis.castShadow = true;
                group.add(chassis);

                // 2. Cabin
                const cabin = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.5, 2.0),
                    new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 1.0, roughness: 0.0 })
                );
                cabin.position.set(0, 1.25, -0.2);
                group.add(cabin);

                // 3. Spoiler (if upgraded)
                if(type > 0) {
                    const wing = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 0.6), chassisMat);
                    wing.position.set(0, 1.4, 2.0);
                    group.add(wing);
                }

                // 4. Wheels
                const wGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
                const wMat = new THREE.MeshStandardMaterial({ color: 0x111 });
                const pos = [{x:1.1, z:1.2}, {x:-1.1, z:1.2}, {x:1.1, z:-1.4}, {x:-1.1, z:-1.4}];
                pos.forEach(p => {
                    const w = new THREE.Mesh(wGeo, wMat);
                    w.rotation.z = Math.PI/2;
                    w.position.set(p.x, 0.4, p.z);
                    w.castShadow = true;
                    group.add(w);
                });

                // 5. Glow (Neon Underglow)
                const light = new THREE.PointLight(bodyColor, 1, 10);
                light.position.set(0, 0.5, 0);
                group.add(light);

                return group;
            },

            spawnMe(type) {
                if(this.myCar.mesh) this.scene.remove(this.myCar.mesh);
                
                const mesh = this.createCar(type, 0xffffff);
                mesh.position.set(110, 0.5, 0); // Start Line
                this.scene.add(mesh);
                
                this.myCar.mesh = mesh;
                this.myCar.type = type;
                
                // Set stats based on car type
                const stats = this.shopData[type];
                this.config.maxSpeed = stats.speed;
                this.config.turn = 0.04 * stats.grip; // better grip = tighter turn? No, simpler: better grip = less drift
            },

            spawnOther(p) {
                if(this.players[p.id]) this.scene.remove(this.players[p.id].mesh);
                const mesh = this.createCar(p.carId || 0, p.color);
                mesh.position.set(p.x, p.y, p.z);
                this.scene.add(mesh);
                this.players[p.id] = { mesh: mesh, target: p };
            },

            // --- NETWORKING ---
            connect() {
                this.socket = io();
                
                this.socket.on('welcome', (data) => {
                    this.myId = data.id;
                    this.shopData = data.shop;
                    this.economy.money = data.list[this.myId].money;
                    this.economy.owned = data.list[this.myId].owned;
                    this.updateUI();
                    
                    this.spawnMe(data.list[this.myId].carId);
                    
                    // Spawn existing
                    Object.values(data.list).forEach(p => {
                        if(p.id !== this.myId) this.spawnOther(p);
                    });
                });

                this.socket.on('playerJoin', p => this.spawnOther(p));
                
                this.socket.on('playerUpdate', p => {
                    if(this.players[p.id]) {
                        const car = this.players[p.id].mesh;
                        // Simple Lerp
                        car.position.lerp(new THREE.Vector3(p.x, p.y, p.z), 0.3);
                        car.quaternion.slerp(new THREE.Quaternion(p.qx, p.qy, p.qz, p.qw), 0.3);
                        // Particles if speeding
                        if(Math.abs(p.s) > 0.5) this.particles.emit(car.position);
                    }
                });

                this.socket.on('playerLeave', id => {
                    if(this.players[id]) {
                        this.scene.remove(this.players[id].mesh);
                        delete this.players[id];
                    }
                });

                this.socket.on('economyUpdate', data => {
                    this.economy.money = data.money;
                    this.economy.owned = data.owned;
                    if(data.car !== undefined) this.spawnMe(data.car);
                    this.updateUI();
                    this.showNotif("TRANSACTION SUCCESSFUL");
                });

                this.socket.on('raceStart', () => {
                    this.showNotif("ðŸ RACE STARTED! GO!");
                    document.getElementById('race-ui').style.opacity = 0;
                });
                
                this.socket.on('raceStatus', s => {
                    document.getElementById('race-ui').style.opacity = 1;
                    document.getElementById('race-text').innerText = `RACERS READY: ${s.count}`;
                });

                this.socket.on('raceOver', d => {
                    this.showNotif(`ðŸ† WINNER: ${d.winner}`);
                    document.getElementById('race-ui').style.opacity = 1;
                    document.getElementById('race-text').innerText = "RACE FINISHED";
                });
            },

            // --- INPUT & PHYSICS ---
            setupInputs() {
                document.addEventListener('keydown', e => { if(this.keys[e.key] !== undefined) this.keys[e.key] = 1; });
                document.addEventListener('keyup', e => { if(this.keys[e.key] !== undefined) this.keys[e.key] = 0; });
            },

            updatePhysics() {
                if(!this.myCar.mesh) return;

                const dt = 0.016; // fixed step approximation
                const car = this.myCar;

                // 1. Acceleration
                if(this.keys.ArrowUp) car.speed += this.config.accel;
                if(this.keys.ArrowDown) car.speed -= this.config.accel;
                
                // Friction
                car.speed *= 0.98;
                
                // 2. Steering (Smooth)
                let targetSteer = 0;
                if(Math.abs(car.speed) > 0.1) {
                    const dir = car.speed > 0 ? 1 : -1;
                    if(this.keys.ArrowLeft) targetSteer = this.config.turn * dir;
                    if(this.keys.ArrowRight) targetSteer = -this.config.turn * dir;
                }
                
                // Lerp steering (Inertia)
                car.steer += (targetSteer - car.steer) * 0.1;

                // 3. Rotation (Quaternion)
                const mesh = car.mesh;
                mesh.rotateY(car.steer * Math.abs(car.speed) * 2.0);

                // 4. Position
                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(mesh.quaternion);
                // Drift factor: if Space is held, we slide more
                const slide = this.keys[" "] ? 0.99 : 0.0;
                
                mesh.position.add(forward.multiplyScalar(car.speed));

                // 5. Ground Clamping (Pseudo Terrain)
                const h = Math.sin(mesh.position.x*0.02)*5 + Math.cos(mesh.position.z*0.015)*5 + Math.sin(mesh.position.x*0.05 + mesh.position.z*0.05)*2;
                const targetY = h > 0 ? h + 0.5 : 0.5;
                mesh.position.y += (targetY - mesh.position.y) * 0.2; // Smooth suspension

                // 6. Camera Follow
                const camOffset = new THREE.Vector3(0, 10, -20).applyQuaternion(mesh.quaternion);
                const camPos = mesh.position.clone().add(camOffset);
                this.camera.position.lerp(camPos, 0.1);
                this.camera.lookAt(mesh.position);

                // 7. Audio Update
                this.audio.update(Math.abs(car.speed) / this.config.maxSpeed);

                // 8. Particles
                if((this.keys[" "] && Math.abs(car.speed) > 0.5) || Math.abs(car.speed) > 0.8) {
                    this.particles.emit(mesh.position);
                }

                // 9. Network Send
                this.socket.emit('move', {
                    x: mesh.position.x, y: mesh.position.y, z: mesh.position.z,
                    qx: mesh.quaternion.x, qy: mesh.quaternion.y, qz: mesh.quaternion.z, qw: mesh.quaternion.w,
                    s: car.speed,
                    st: car.steer
                });

                // 10. Lap Logic
                this.checkLap(mesh.position);

                // 11. UI Update
                const kmh = Math.floor(Math.abs(car.speed) * 200);
                document.getElementById('speed-num').innerText = kmh;
                document.getElementById('rpm-fill').style.width = Math.min((kmh / 240)*100, 100) + "%";
                document.getElementById('gear-label').innerText = kmh > 150 ? "3" : (kmh > 80 ? "2" : "1");
            },

            checkLap(pos) {
                // Simple polar coordinate check
                const angle = Math.atan2(pos.z, pos.x);
                // Define 4 sectors
                let sector = 0;
                if(angle >= 0 && angle < 1.57) sector = 1;
                else if(angle >= 1.57) sector = 2;
                else if(angle < -1.57) sector = 3;
                else sector = 4;
                
                // Logic needs server validation ideally, but sending lap finish here
                // ... (Simplified for length) ...
                if(sector === 1 && Math.abs(pos.x - 110) < 10 && Math.abs(pos.z) < 20) {
                     // Finish Line Check logic would go here
                     // For now, just a button to join race handles logic
                }
            },

            // --- UI & SHOP ---
            toggleShop() {
                const modal = document.getElementById('shop-modal');
                const grid = document.getElementById('shop-grid');
                if(modal.style.display === 'flex') {
                    modal.style.display = 'none';
                } else {
                    modal.style.display = 'flex';
                    grid.innerHTML = '';
                    // Generate Cards
                    Object.keys(this.shopData).forEach(id => {
                        const item = this.shopData[id];
                        const owned = this.economy.owned.includes(parseInt(id));
                        const equipped = this.myCar.type == id;
                        
                        let action = `Game.socket.emit('buy', ${id})`;
                        let btnText = `BUY $${item.price}`;
                        let btnStyle = `border:1px solid #333; background:transparent; color:white;`;
                        
                        if(owned) {
                            action = `Game.socket.emit('equip', ${id})`;
                            btnText = "EQUIP";
                            btnStyle = "background:#00f2ff; color:black; font-weight:bold;";
                        }
                        if(equipped) {
                            btnText = "DRIVING";
                            btnStyle = "background:#333; color:#555; cursor:default;";
                        }

                        const div = document.createElement('div');
                        div.className = 'car-card';
                        div.innerHTML = `
                            <div class="car-name">${item.name}</div>
                            <div class="car-price">${owned ? "OWNED" : "$"+item.price}</div>
                            <div style="text-align:left; font-size:12px; color:#aaa;">
                                SPEED <div class="stat-bar"><div class="stat-fill" style="width:${(item.speed/2.5)*100}%"></div></div>
                                GRIP <div class="stat-bar"><div class="stat-fill" style="width:${(item.grip)*100}%"></div></div>
                            </div>
                            <button onclick="${action}" style="margin-top:15px; padding:10px; width:100%; border-radius:5px; cursor:pointer; ${btnStyle}">${btnText}</button>
                        `;
                        grid.appendChild(div);
                    });
                }
            },

            updateUI() {
                document.getElementById('money-val').innerText = this.economy.money;
            },

            showNotif(msg) {
                const d = document.createElement('div');
                d.className = 'notif';
                d.innerText = msg;
                document.getElementById('notif-area').appendChild(d);
                setTimeout(() => d.remove(), 3500);
            },

            joinRace() {
                this.socket.emit('joinRace');
            },

            animate() {
                requestAnimationFrame(this.animate);
                this.updatePhysics();
                this.particles.update();
                this.renderer.render(this.scene, this.camera);
            }
