<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ULTIMATE RACER 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI Black', sans-serif; }
        
        /* HUD */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #money-badge { position: absolute; top: 20px; right: 20px; background: linear-gradient(90deg, #11998e, #38ef7d); padding: 10px 30px; border-radius: 50px; font-size: 24px; color: white; transform: skewX(-15deg); box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        
        #garage-btn { pointer-events: all; position: absolute; top: 80px; right: 20px; background: #333; color: white; border: 2px solid white; padding: 10px 20px; cursor: pointer; transform: skewX(-15deg); transition: 0.2s; }
        #garage-btn:hover { background: white; color: black; }

        #race-panel { pointer-events: all; position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; }
        #join-race-btn { background: linear-gradient(45deg, #ff416c, #ff4b2b); border: none; padding: 15px 40px; font-size: 20px; color: white; border-radius: 30px; cursor: pointer; box-shadow: 0 0 20px #ff4b2b; animation: pulse 2s infinite; }
        
        #speedo { position: absolute; bottom: 30px; right: 40px; text-align: right; color: white; text-shadow: 2px 2px 0 #000; }
        #speed-val { font-size: 70px; line-height: 0.8; font-style: italic; }
        
        /* SHOP OVERLAY */
        #shop-overlay { display: none; pointer-events: all; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); z-index: 99; flex-direction: column; justify-content: center; align-items: center; color: white; }
        .car-card { display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.1); width: 600px; margin: 10px; padding: 20px; border-radius: 10px; border: 1px solid #555; }
        .car-stats { font-size: 14px; color: #aaa; }
        .buy-btn { padding: 10px 20px; border: none; cursor: pointer; font-weight: bold; text-transform: uppercase; }
        .btn-owned { background: #444; color: #888; cursor: default; }
        .btn-buy { background: #38ef7d; color: black; }
        .btn-equip { background: #00d2ff; color: black; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="money-badge">$<span id="cash">0</span></div>
        <button id="garage-btn" onclick="toggleShop()">GARAGE / SHOP</button>
        
        <div id="race-panel">
            <button id="join-race-btn" onclick="joinRace()">JOIN RACE</button>
            <h2 id="race-status" style="color:white; text-shadow:0 2px 4px black; display:none;">WAITING...</h2>
        </div>

        <div id="speedo">
            <div id="speed-val">0</div>
            <div>KM/H</div>
        </div>
    </div>

    <!-- SHOP MENU -->
    <div id="shop-overlay">
        <h1>CAR DEALERSHIP</h1>
        <h3 style="color:#38ef7d">WIN RACES TO EARN CASH</h3>
        <div id="car-list"></div>
        <button onclick="toggleShop()" style="margin-top:20px; padding:10px 30px; background:transparent; border:2px solid white; color:white; cursor:pointer;">CLOSE</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // --- CONFIG ---
        const CAR_SPECS = {
            0: { maxSpeed: 1.0, accel: 0.02, turn: 0.04, color: 0x3498db }, // Rookie
            1: { maxSpeed: 1.3, accel: 0.03, turn: 0.045, color: 0xe74c3c }, // Tuner
            2: { maxSpeed: 1.6, accel: 0.04, turn: 0.035, color: 0xf1c40f }, // Muscle
            3: { maxSpeed: 2.2, accel: 0.05, turn: 0.05, color: 0x9b59b6 }   // F1
        };

        // --- GLOBALS ---
        let scene, camera, renderer, clock, socket, myId;
        let players = {};
        let myCar = { mesh: null, chassis: null, speed: 0, actualSteering: 0, type: 0 };
        let inputs = { up: false, down: false, left: false, right: false, space: false };
        let economy = { money: 0, owned: [0] };
        let simplex = new SimplexNoise(); // For terrain generation

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 200);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.left = -100; sun.shadow.camera.right = 100;
            sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100;
            scene.add(sun);

            createTerrain();
            createTrack();

            socket = io();
            setupNetwork();

            clock = new THREE.Clock();
            setupInputs();
            window.addEventListener('resize', onResize);
            animate();
        }

        // --- TERRAIN PHYSICS ---
        function getTerrainHeight(x, z) {
            // Combine large rolling hills with small bumps
            let y = simplex.noise2D(x * 0.005, z * 0.005) * 10;
            y += simplex.noise2D(x * 0.02, z * 0.02) * 2;
            
            // Flatten the start area/track area slightly (simplified)
            const dist = Math.sqrt(x*x + z*z);
            if(dist < 150 && dist > 50) y *= 0.2; // Track area flatter
            
            return y > 0 ? y : 0; // Water level clamp
        }

        function createTerrain() {
            const geo = new THREE.PlaneGeometry(600, 600, 128, 128);
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i); // Plane is XY, rotated later
                // Calculate height
                const z = getTerrainHeight(x, -y); // Map Z to Y
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            
            const mat = new THREE.MeshStandardMaterial({ color: 0x3b8c40, roughness: 0.9 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add(mesh);
        }

        function createTrack() {
            // A visual ring to indicate the race path
            const trackGeo = new THREE.RingGeometry(90, 130, 64);
            const trackMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.rotation.x = -Math.PI/2;
            track.position.y = 0.5; // Just above flat level
            track.receiveShadow = true;
            scene.add(track);
        }

        // --- CAR PHYSICS & VISUALS ---
        function createCarMesh(color) {
            const root = new THREE.Group();

            // Suspension wrapper (tilts)
            const chassis = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(2, 0.5, 4);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.2 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            chassis.add(body);

            // Cabin
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0x111 }));
            cabin.position.set(0, 1.0, -0.5);
            chassis.add(cabin);

            // Wheels
            const wGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x222 });
            const wheels = [
                {x: 1.1, z: 1.2}, {x: -1.1, z: 1.2},
                {x: 1.1, z: -1.2}, {x: -1.1, z: -1.2}
            ];
            wheels.forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI/2;
                w.position.set(p.x, 0.4, p.z);
                w.castShadow = true;
                root.add(w); // Wheels attached to root (axles), not tilting chassis
            });

            root.add(chassis);
            return { root: root, chassis: chassis };
        }

        function updatePhysics() {
            if(!myCar.mesh) return;
            const stats = CAR_SPECS[myCar.type];

            // 1. Acceleration
            if(inputs.up) myCar.speed += stats.accel;
            if(inputs.down) myCar.speed -= stats.accel;
            myCar.speed *= 0.98; // Friction

            // 2. Smooth Steering (Interpolation)
            let targetSteering = 0;
            if(Math.abs(myCar.speed) > 0.1) {
                const dir = myCar.speed > 0 ? 1 : -1;
                if(inputs.left) targetSteering = stats.turn * dir;
                if(inputs.right) targetSteering = -stats.turn * dir;
            }
            // LERP: Move actual steering towards target slowly
            myCar.actualSteering += (targetSteering - myCar.actualSteering) * 0.1;

            // Apply rotation
            myCar.mesh.root.rotation.y += myCar.actualSteering * Math.abs(myCar.speed) * 1.5;

            // 3. Movement
            const rot = myCar.mesh.root.rotation.y;
            myCar.mesh.root.position.x -= Math.sin(rot) * myCar.speed;
            myCar.mesh.root.position.z -= Math.cos(rot) * myCar.speed;

            // 4. TERRAIN HEIGHT (Suspension)
            const x = myCar.mesh.root.position.x;
            const z = myCar.mesh.root.position.z;
            const h = getTerrainHeight(x, z);
            
            // Smoothly move Y to terrain height
            myCar.mesh.root.position.y += (h - myCar.mesh.root.position.y) * 0.2;

            // 5. VISUAL TILT (Suspension Physics)
            // Roll (Side to side based on turning)
            const roll = -myCar.actualSteering * 8.0; 
            // Pitch (Squat based on acceleration)
            const pitch = -myCar.speed * 0.5;

            myCar.chassis.rotation.z += (roll - myCar.chassis.rotation.z) * 0.1;
            myCar.chassis.rotation.x += (pitch - myCar.chassis.rotation.x) * 0.1;

            // 6. Camera
            camera.position.x += (myCar.mesh.root.position.x - Math.sin(rot)*-20 - camera.position.x) * 0.1;
            camera.position.z += (myCar.mesh.root.position.z - Math.cos(rot)*-20 - camera.position.z) * 0.1;
            camera.position.y += (myCar.mesh.root.position.y + 10 - camera.position.y) * 0.1;
            camera.lookAt(myCar.mesh.root.position);

            // Update UI
            document.getElementById('speed-val').innerText = Math.floor(Math.abs(myCar.speed) * 200);

            // Send to Server
            socket.emit('playerMovement', {
                x: x, y: myCar.mesh.root.position.y, z: z,
                ry: rot,
                tilt: myCar.chassis.rotation.z
            });

            checkLap();
        }

        // --- RACE & LAPS ---
        let lastCheckpoint = -1;
        function checkLap() {
            // Simple angular checkpoint system based on atan2
            const x = myCar.mesh.root.position.x;
            const z = myCar.mesh.root.position.z;
            const angle = Math.atan2(z, x); // -PI to PI
            
            // Checkpoints roughly at quarters
            if(angle > 0 && angle < 1.5) currentCP = 1;
            else if(angle > 1.5) currentCP = 2;
            else if(angle < -1.5) currentCP = 3;
            else currentCP = 0;

            if(currentCP === 0 && lastCheckpoint === 3) {
                // Completed Lap
                socket.emit('lapFinished');
                console.log("Lap Finished");
            }
            lastCheckpoint = currentCP;
        }

        // --- SHOP & UI ---
        function toggleShop() {
            const div = document.getElementById('shop-overlay');
            div.style.display = div.style.display === 'flex' ? 'none' : 'flex';
            if(div.style.display === 'flex') renderShop();
        }

        function renderShop() {
            const list = document.getElementById('car-list');
            list.innerHTML = '';
            
            // Request shop data if needed, but we init with it
            // We'll iterate manually for now based on known config
            [0, 1, 2, 3].forEach(id => {
                const spec = CAR_SPECS[id];
                const card = document.createElement('div');
                card.className = "car-card";
                
                const cost = [0, 500, 1500, 5000][id];
                const name = ["Rookie Kart", "Street Tuner", "Muscle Car", "F1 Prototype"][id];
                const owned = economy.owned.includes(id);

                let btnHTML = '';
                if(myCar.type === id) btnHTML = `<button class="buy-btn btn-owned">EQUIPPED</button>`;
                else if(owned) btnHTML = `<button class="buy-btn btn-equip" onclick="socket.emit('equipCar', ${id})">EQUIP</button>`;
                else if(economy.money >= cost) btnHTML = `<button class="buy-btn btn-buy" onclick="socket.emit('buyCar', ${id})">BUY $${cost}</button>`;
                else btnHTML = `<button class="buy-btn btn-owned">LOCKED $${cost}</button>`;

                card.innerHTML = `
                    <div>
                        <h2 style="margin:0; color: #${spec.color.toString(16)}">${name}</h2>
                        <div class="car-stats">Speed: ${spec.maxSpeed} | Accel: ${spec.accel} | Grip: ${1/spec.turn}</div>
                    </div>
                    ${btnHTML}
                `;
                list.appendChild(card);
            });
        }

        function joinRace() {
            document.getElementById('join-race-btn').style.display = 'none';
            document.getElementById('race-status').style.display = 'block';
            socket.emit('joinRace');
        }

        // --- NETWORK HANDLERS ---
        function setupNetwork() {
            socket.on('initData', (data) => {
                myId = data.id;
                economy.money = data.players[myId].money;
                economy.owned = data.players[myId].ownedCars;
                document.getElementById('cash').innerText = economy.money;
                
                // Spawn Me
                spawnMe(data.players[myId].carType);
            });

            socket.on('playerMoved', (p) => {
                if(players[p.id]) {
                    const obj = players[p.id].mesh;
                    obj.root.position.lerp(new THREE.Vector3(p.x, p.y, p.z), 0.2);
                    
                    // Rotation Interp
                    let rotDiff = p.ry - obj.root.rotation.y;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    obj.root.rotation.y += rotDiff * 0.2;
                    
                    // Tilt Interp
                    obj.chassis.rotation.z += (p.tilt - obj.chassis.rotation.z) * 0.2;
                }
            });

            socket.on('newPlayer', (p) => { spawnOther(p); });
            socket.on('updateEconomy', (data) => {
                economy.money = data.money;
                economy.owned = data.owned;
                document.getElementById('cash').innerText = economy.money;
                if(document.getElementById('shop-overlay').style.display === 'flex') renderShop();
            });

            socket.on('playerSwitchedCar', (data) => {
                if(data.id === myId) {
                    scene.remove(myCar.mesh.root);
                    spawnMe(data.carType);
                    toggleShop(); // close shop
                } else if (players[data.id]) {
                    scene.remove(players[data.id].mesh.root);
                    const p = players[data.id].data; // preserve pos
                    p.carType = data.carType;
                    spawnOther(p);
                }
            });

            socket.on('raceStart', () => {
                document.getElementById('race-status').innerText = "GO GO GO!";
                setTimeout(() => document.getElementById('race-status').style.display = 'none', 2000);
            });
            
            socket.on('raceMessage', (msg) => {
                alert(msg); // Simple alert for win
                document.getElementById('join-race-btn').style.display = 'block';
            });
        }

        function spawnMe(type) {
            const spec = CAR_SPECS[type];
            const obj = createCarMesh(spec.color);
            scene.add(obj.root);
            myCar.mesh = obj;
            myCar.chassis = obj.chassis;
            myCar.type = type;
        }

        function spawnOther(p) {
            // Need to know their car type (simplified default if unknown)
            const type = p.carType || 0;
            const spec = CAR_SPECS[type];
            const obj = createCarMesh(spec.color);
            obj.root.position.set(p.x, p.y || 0.5, p.z);
            scene.add(obj.root);
            players[p.id] = { mesh: obj, data: p };
        }

        // --- UTILS ---
        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupInputs() {
            document.addEventListener('keydown', e => {
                if(e.key === 'ArrowUp') inputs.up = true;
                if(e.key === 'ArrowDown') inputs.down = true;
                if(e.key === 'ArrowLeft') inputs.left = true;
                if(e.key === 'ArrowRight') inputs.right = true;
            });
            document.addEventListener('keyup', e => {
                if(e.key === 'ArrowUp') inputs.up = false;
                if(e.key === 'ArrowDown') inputs.down = false;
                if(e.key === 'ArrowLeft') inputs.left = false;
                if(e.key === 'ArrowRight') inputs.right = false;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
