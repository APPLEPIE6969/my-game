<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TURBO DRIFT: FIXED</title>
    <style>
        :root { --neon: #00f3ff; --danger: #ff0055; --bg: #000; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; user-select: none; color: white; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        
        .card { pointer-events: auto; background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.2); padding: 10px 20px; border-radius: 8px; backdrop-filter: blur(10px); display: flex; gap: 15px; align-items: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .money { font-size: 24px; font-weight: 900; color: #fff; }
        .money span { color: var(--neon); }
        
        #minimap-wrapper { pointer-events: auto; width: 220px; height: 220px; margin-top: 15px; border: 3px solid #333; border-radius: 50%; overflow: hidden; background: rgba(0,0,0,0.9); cursor: pointer; transition: 0.2s; position: relative; }
        #minimap-wrapper:hover { border-color: var(--neon); transform: scale(1.05); }
        #minimap-canvas { width: 100%; height: 100%; object-fit: cover; }
        #minimap-wrapper::after { content: '‚ñ≤'; position: absolute; top: 50%; left: 50%; color: var(--neon); transform: translate(-50%, -50%); font-size: 20px; text-shadow: 0 0 5px var(--neon); }

        #track-select { pointer-events: auto; display: flex; flex-direction: column; gap: 5px; margin-top: 15px; }
        .track-btn { background: linear-gradient(90deg, #222, #111); border: 1px solid #444; color: #ccc; padding: 8px 15px; cursor: pointer; text-align: left; font-weight: bold; transition: 0.2s; }
        .track-btn:hover { border-color: var(--neon); color: white; padding-left: 20px; }

        #race-panel { text-align: center; position: absolute; top: 100px; left: 50%; transform: translateX(-50%); }
        #lap-counter { font-size: 60px; font-weight: 900; font-style: italic; text-shadow: 0 0 20px var(--neon); display: none; }
        #join-btn { padding: 15px 50px; font-size: 24px; background: linear-gradient(45deg, #ff8800, #ff4400); animation: pulse 2s infinite; pointer-events: auto; cursor: pointer; border: none; color: white; font-weight: 900; transform: skewX(-10deg); }
        
        #msg-area { position: absolute; top: 250px; width: 100%; text-align: center; pointer-events: none; }
        .msg { display: inline-block; background: rgba(0,0,0,0.8); padding: 10px 40px; border-radius: 4px; border-left: 5px solid var(--neon); margin-bottom: 5px; font-weight: bold; font-size: 20px; animation: fade 4s forwards; }

        .hud-bot { display: flex; justify-content: space-between; align-items: flex-end; }
        .speedo { text-align: right; }
        .speed-val { font-size: 100px; font-weight: 900; line-height: 0.8; font-style: italic; letter-spacing: -2px; }
        .bar-bg { width: 350px; height: 15px; background: #222; margin-top: 5px; border-radius: 2px; overflow: hidden; transform: skewX(-20deg); }
        .bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--neon), var(--danger)); transition: width 0.05s; }
        
        #shop { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 99; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; max-width: 900px; }
        .item { border: 1px solid #444; padding: 30px; border-radius: 10px; text-align: center; background: rgba(255,255,255,0.05); transition: 0.3s; }
        .item:hover { border-color: var(--neon); transform: scale(1.05); }

        #respawn-btn { pointer-events: auto; display: none; background: #333; border: 1px solid #666; position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 10px 30px; color: white; cursor: pointer; font-weight: bold; }

        @keyframes pulse { 0% { transform: scale(1) skewX(-10deg); } 50% { transform: scale(1.05) skewX(-10deg); } 100% { transform: scale(1) skewX(-10deg); } }
        @keyframes fade { 0% { opacity: 0; transform: translateY(20px); } 10% { opacity: 1; transform: translateY(0); } 90% { opacity: 1; } 100% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div style="display:flex; justify-content:space-between; align-items: flex-start;">
            <div>
                <div class="card">
                    <div class="money"><span>$</span><span id="cash">0</span></div>
                    <button style="margin-left:15px; background:var(--neon); border:none; padding:8px 20px; font-weight:bold; cursor:pointer;" onclick="Game.toggleShop()">GARAGE</button>
                </div>
                
                <div id="minimap-wrapper">
                    <canvas id="minimap-canvas" width="220" height="220"></canvas>
                </div>

                <div id="track-select">
                    <button class="track-btn" onclick="Game.loadLevel(0)">üèÅ SERPENT CIRCUIT (Day)</button>
                    <button class="track-btn" onclick="Game.loadLevel(1)">üåÉ NEON CITY (Night)</button>
                    <button class="track-btn" onclick="Game.loadLevel(2)">üèúÔ∏è CANYON RUN (Rally)</button>
                </div>
            </div>
            <div class="card">
                <div style="font-size:12px; font-weight:bold; color:#aaa;">ONLINE: <span id="p-count" style="color:white; font-size:18px;">1</span></div>
            </div>
        </div>

        <div id="race-panel">
            <button id="join-btn" onclick="Game.joinRace()">JOIN RACE</button>
            <div id="lap-counter">LAP <span id="lap-val">1</span> / 5</div>
        </div>

        <div id="msg-area"></div>
        <button id="respawn-btn" onclick="Game.respawn()">RESPAWN (R)</button>

        <div class="hud-bot">
            <div style="color:#888; font-size:12px; font-weight:bold;">ARROWS: Drive | SHIFT: Drift | R: Respawn | C: Cam</div>
            <div class="speedo">
                <div class="speed-val" id="speed">0</div>
                <div style="color:var(--neon); font-weight:bold; letter-spacing:4px; font-size:14px;">KM/H</div>
                <div class="bar-bg"><div class="bar-fill" id="rpm"></div></div>
            </div>
        </div>
    </div>

    <div id="shop">
        <h1 style="font-size:60px; margin-bottom:40px; font-style:italic;">DEALERSHIP</h1>
        <div class="grid" id="shop-grid"></div>
        <button onclick="Game.toggleShop()" style="margin-top:40px; background:transparent; border:2px solid #666; color:white; padding:15px 40px; cursor:pointer; font-weight:bold;">EXIT SHOP</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // ========================================================
        // üîä AUDIO ENGINE (Combustion)
        // ========================================================
        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createDynamicsCompressor();
                this.master.connect(this.ctx.destination);
                this.init = false;
            }
            start() {
                if(this.init) return;
                this.ctx.resume();
                // Engine Rumble (Filtered Noise)
                const bufSize = this.ctx.sampleRate * 2;
                const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for(let i=0; i<bufSize; i++) data[i] = (Math.random()*2-1) * 0.5;
                
                this.src = this.ctx.createBufferSource();
                this.src.buffer = buf;
                this.src.loop = true;
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.gain = this.ctx.createGain();
                
                this.src.connect(this.filter);
                this.filter.connect(this.gain);
                this.gain.connect(this.master);
                this.src.start();
                this.init = true;
            }
            update(speed) {
                if(!this.init) return;
                // Pitch rises with speed
                this.src.playbackRate.setTargetAtTime(0.5 + (speed*1.5), this.ctx.currentTime, 0.1);
                // Filter opens with speed
                this.filter.frequency.setTargetAtTime(100 + (speed*800), this.ctx.currentTime, 0.1);
                // Volume
                this.gain.gain.setTargetAtTime(0.3 + (speed*0.4), this.ctx.currentTime, 0.1);
            }
        }

        // ========================================================
        // üèéÔ∏è DETAILED CAR GENERATOR
        // ========================================================
        class CarFactory {
            static create(color) {
                const car = new THREE.Group();
                const mainColor = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.7 });
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
                const glassMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.0, metalness: 1.0 });
                const glowRed = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const glowWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });

                // 1. Chassis (Lower)
                const chassis = new THREE.Mesh(new THREE.BoxGeometry(2.1, 0.6, 4.6), mainColor);
                chassis.position.y = 0.6;
                chassis.castShadow = true;
                car.add(chassis);

                // 2. Cabin (Upper)
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.55, 2.2), glassMat);
                cabin.position.set(0, 1.15, -0.2);
                car.add(cabin);

                // 3. Wheel Arches (Fenders)
                const fenderGeo = new THREE.BoxGeometry(2.3, 0.4, 1.2);
                const frontFender = new THREE.Mesh(fenderGeo, mainColor);
                frontFender.position.set(0, 0.6, -1.4);
                car.add(frontFender);
                const rearFender = new THREE.Mesh(fenderGeo, mainColor);
                rearFender.position.set(0, 0.6, 1.3);
                car.add(rearFender);

                // 4. Spoiler
                const wing = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 0.5), blackMat);
                wing.position.set(0, 1.3, 2.1);
                const poleL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.2), blackMat);
                poleL.position.set(0.8, 1.1, 2.1);
                const poleR = poleL.clone();
                poleR.position.set(-0.8, 1.1, 2.1);
                car.add(wing); car.add(poleL); car.add(poleR);

                // 5. Lights
                const tailL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), glowRed);
                tailL.position.set(0.6, 0.7, 2.31);
                const tailR = tailL.clone();
                tailR.position.set(-0.6, 0.7, 2.31);
                car.add(tailL); car.add(tailR);

                const headL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), glowWhite);
                headL.position.set(0.6, 0.6, -2.31);
                const headR = headL.clone();
                headR.position.set(-0.6, 0.6, -2.31);
                car.add(headL); car.add(headR);

                // 6. Wheels (Rim + Tire)
                const wheelGroup = new THREE.Group();
                const tireGeo = new THREE.CylinderGeometry(0.42, 0.42, 0.35, 16);
                const rimGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.36, 8);
                const tireMat = new THREE.MeshLambertMaterial({color:0x111});
                const rimMat = new THREE.MeshStandardMaterial({color:0x888, metalness:0.8});

                const pos = [{x:1.1, z:1.3}, {x:-1.1, z:1.3}, {x:1.1, z:-1.4}, {x:-1.1, z:-1.4}];
                pos.forEach(p => {
                    const w = new THREE.Group();
                    const t = new THREE.Mesh(tireGeo, tireMat); t.rotation.z = Math.PI/2;
                    const r = new THREE.Mesh(rimGeo, rimMat); r.rotation.z = Math.PI/2;
                    w.add(t); w.add(r);
                    w.position.set(p.x, 0.42, p.z);
                    w.castShadow = true;
                    wheelGroup.add(w);
                });
                car.userData.wheels = wheelGroup; // Ref for rotation
                car.add(wheelGroup);

                return car;
            }
        }

        // ========================================================
        // üèéÔ∏è PHYSICS
        // ========================================================
        class CarPhysics {
            constructor(stats, color) {
                this.stats = stats;
                this.mesh = CarFactory.create(color);
                this.pos = new THREE.Vector3(0, 10, 0); // SPAWN HIGH
                this.velocity = new THREE.Vector3();
                this.quat = new THREE.Quaternion();
                this.speed = 0;
                this.rotVel = 0;
                this.checkpoint = 0;
                this.lap = 1;
                this.lastSafePos = new THREE.Vector3(0, 10, 0);
            }

            update(inputs, dt, terrainFn, onRoad) {
                const h = terrainFn(this.pos.x, this.pos.z);
                
                // 1. Engine
                let accel = 0;
                // FIX: Inverted inputs for correct direction (Forward is -Z)
                if(inputs.ArrowUp) accel = -this.stats.accel; 
                if(inputs.ArrowDown) accel = this.stats.accel;
                
                // Friction / Offroad
                if(!onRoad && Math.abs(this.speed) > 0.2) this.speed *= 0.94;
                this.speed += accel;
                this.speed *= 0.98; // Drag

                // 2. Steering - FLIPPED SIGNS FOR CORRECT STEERING
                if(Math.abs(this.speed) > 0.1) {
                    const dir = this.speed > 0 ? 1 : -1; // Moving forward (neg Z) = -1
                    const turnForce = this.stats.turn * 3.0; 
                    // Flip Logic: Left key should rotate POSITIVE Y to turn LEFT
                    // If moving forward (-Z), dir is -1. 
                    // So we want: inputs.ArrowLeft -> +Rot
                    if(inputs.ArrowLeft) this.rotVel -= turnForce * dt * dir; 
                    if(inputs.ArrowRight) this.rotVel += turnForce * dt * dir;
                }
                this.rotVel *= 0.85; // Snappy damping

                const q = new THREE.Quaternion();
                q.setFromAxisAngle(new THREE.Vector3(0,1,0), this.rotVel);
                this.quat.multiply(q).normalize();

                // 3. Movement
                const fwd = new THREE.Vector3(0,0,1).applyQuaternion(this.quat);
                const grip = inputs.Shift ? 0.05 : 0.8;
                const targetVel = fwd.clone().multiplyScalar(this.speed);
                this.velocity.lerp(targetVel, grip);

                this.pos.add(this.velocity);
                
                // Gravity / Terrain Snap
                if(this.pos.y < h + 0.5) {
                    this.pos.y = h + 0.5;
                } else {
                    this.pos.y -= 0.5; // Gravity
                }

                // 4. Visuals
                this.mesh.position.copy(this.pos);
                this.mesh.quaternion.copy(this.quat);
                
                // Wheel Spin
                this.mesh.userData.wheels.children.forEach(w => w.rotation.x += this.speed);
                
                // Body Tilt
                this.mesh.children[0].rotation.z = -this.rotVel * 4; // Roll
                this.mesh.children[0].rotation.x = this.speed * 0.05; // Pitch

                if(inputs.Shift && Math.abs(this.speed) > 0.5) Game.emitSmoke(this.pos);
            }
        }

        // ========================================================
        // üåç GAME MANAGER
        // ========================================================
        const Game = {
            socket: null, scene: null, camera: null, renderer: null, audio: new AudioController(),
            input: { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, Shift:false },
            players: {}, myCar: null, racing: false, camIndex: 0,
            
            // Map Data
            currentLevel: 0,
            levelData: null,
            simplex: new SimplexNoise(),

            init() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                // Default Light
                const amb = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(amb);
                const sun = new THREE.DirectionalLight(0xffffff, 1.0);
                sun.position.set(100, 200, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
                this.scene.add(sun);
                this.sun = sun;

                this.setupInputs();
                this.connect();
                this.loadLevel(0); // Start Circuit

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                window.addEventListener('click', () => this.audio.start(), {once:true});
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            },

            loadLevel(id) {
                if(this.terrainMesh) this.scene.remove(this.terrainMesh);
                if(this.trackMesh) { this.scene.remove(this.trackMesh); this.scene.remove(this.trackBorder); }
                if(this.scenery) this.scene.remove(this.scenery);

                this.currentLevel = id;
                this.scenery = new THREE.Group();
                this.scene.add(this.scenery);

                // 1. GENERATE TRACK SPLINE
                let points = [];
                let color = 0x444444;
                
                if(id === 0) { // SERPENT (Circuit)
                    this.scene.background = new THREE.Color(0x87CEEB);
                    this.scene.fog = new THREE.Fog(0x87CEEB, 200, 800);
                    points = [
                        new THREE.Vector3(0,0,0), new THREE.Vector3(200,0,-100), new THREE.Vector3(400,0,0),
                        new THREE.Vector3(300,0,300), new THREE.Vector3(0,0,200), new THREE.Vector3(-200,0,100)
                    ];
                    this.groundColor = 0x2d6e32; // Green
                } 
                else if (id === 1) { // CITY (Night)
                    this.scene.background = new THREE.Color(0x050510);
                    this.scene.fog = new THREE.Fog(0x050510, 100, 500);
                    points = [
                        new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-400), new THREE.Vector3(400,0,-400),
                        new THREE.Vector3(400,0,0), new THREE.Vector3(200,0,200), new THREE.Vector3(-200,0,200)
                    ];
                    this.groundColor = 0x111111; // Asphalt
                    this.spawnBuildings();
                }
                else { // RALLY (Dirt)
                    this.scene.background = new THREE.Color(0xdcae96);
                    this.scene.fog = new THREE.Fog(0xdcae96, 100, 600);
                    points = [
                        new THREE.Vector3(0,0,0), new THREE.Vector3(300,20,-300), new THREE.Vector3(600,-10,0),
                        new THREE.Vector3(300,30,400), new THREE.Vector3(-200,10,200)
                    ];
                    this.groundColor = 0x8B4513; // Dirt
                }

                // 2. BUILD SPLINE
                const curve = new THREE.CatmullRomCurve3(points);
                curve.closed = true;
                const tube = new THREE.TubeGeometry(curve, 100, 15, 3, true);
                this.trackMesh = new THREE.Mesh(tube, new THREE.MeshStandardMaterial({color:0x333}));
                this.trackMesh.rotation.x = Math.PI; // Flip normal issue? No, Tube is fine.
                this.trackMesh.position.y = 0.2;
                this.trackMesh.receiveShadow = true;
                this.scene.add(this.trackMesh);

                // Border
                const wire = new THREE.TubeGeometry(curve, 100, 16, 3, true);
                this.trackBorder = new THREE.Mesh(wire, new THREE.MeshBasicMaterial({color: id===1?0x00f3ff:0xffffff, wireframe:true}));
                this.trackBorder.position.y = 1;
                this.scene.add(this.trackBorder);

                // 3. TERRAIN
                const geo = new THREE.PlaneGeometry(2000, 2000, 128, 128);
                const pos = geo.attributes.position;
                for(let i=0; i<pos.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i);
                    // Get Distance to Track Spline (Approx)
                    // For speed, we just use noise everywhere except center
                    let h = this.simplex.noise2D(x*0.005, y*0.005) * (id===2 ? 30 : 10);
                    if(id === 2 && x > 200) h += 20; // Mountains
                    pos.setZ(i, h);
                }
                geo.computeVertexNormals();
                this.terrainMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:this.groundColor, roughness:0.9}));
                this.terrainMesh.rotation.x = -Math.PI/2;
                this.terrainMesh.receiveShadow = true;
                this.scene.add(this.terrainMesh);

                // Store Level Data
                this.levelData = {
                    curve: curve,
                    checkpoints: curve.getSpacedPoints(40),
                    spawn: points[0]
                };

                // Teleport Player
                if(this.myCar) {
                    this.myCar.pos.copy(points[0]);
                    this.myCar.pos.y = 10; // SPAWN HIGH
                    this.myCar.velocity.set(0,0,0);
                    this.myCar.speed = 0;
                    // Reset Race Logic
                    this.racing = false;
                    this.myCar.lap = 1; 
                    this.myCar.checkpoint = 0;
                }
            },

            spawnBuildings() {
                const geo = new THREE.BoxGeometry(20, 100, 20);
                const mat = new THREE.MeshStandardMaterial({color:0x222, emissive:0x111111});
                for(let i=0; i<60; i++) {
                    const b = new THREE.Mesh(geo, mat);
                    const x = (Math.random()-0.5)*1000;
                    const z = (Math.random()-0.5)*1000;
                    // Don't spawn near center
                    if(Math.sqrt(x*x+z*z) > 100) {
                        b.position.set(x, 50, z);
                        b.scale.y = Math.random()*2 + 0.5;
                        this.scenery.add(b);
                    }
                }
            },

            getTerrainHeight(x, z) {
                // Flatten spawn area (radius 50)
                if(Math.sqrt(x*x + z*z) < 50) return 0;

                // Raycasting is accurate but slow. We use the noise function + track offset.
                let h = this.simplex.noise2D(x*0.005, -z*0.005) * (this.currentLevel===2 ? 30 : 10);
                if(this.currentLevel === 2 && x > 200) h += 20;
                return Math.max(0, h);
            },

            checkOffRoad() {
                if(!this.myCar) return false;
                const p = this.myCar.pos;
                // Find distance to closest point on spline
                // Optimized: Check distance to current checkpoint and next checkpoint
                const cps = this.levelData.checkpoints;
                const i = this.myCar.checkpoint; // Current CP index (approx)
                
                // Check 5 points around current index to find min dist
                let minD = 9999;
                for(let j=-2; j<=2; j++) {
                    let idx = (i + j + cps.length) % cps.length;
                    const d = p.distanceTo(cps[idx]);
                    if(d < minD) minD = d;
                }
                
                return minD < 20; // Track width approx
            },

            // --- NETWORKING ---
            spawnMe(carId) {
                if(this.myCar) this.scene.remove(this.myCar.mesh);
                const colors = [0x3366ff, 0xff3333, 0xffaa00, 0xcc00ff];
                const stats = [{accel:0.02, turn:0.06}, {accel:0.03, turn:0.065}, {accel:0.04, turn:0.06}, {accel:0.06, turn:0.08}];
                this.myCar = new CarPhysics(stats[carId], colors[carId]);
                this.scene.add(this.myCar.mesh);
                // Teleport to current level start
                this.loadLevel(this.currentLevel);
            },

            connect() {
                this.socket = io();
                this.socket.on('welcome', d => {
                    this.myId = d.id;
                    this.economy = {money:d.list[this.myId].money, owned:d.list[this.myId].owned};
                    this.shopData = d.shop;
                    document.getElementById('cash').innerText = this.economy.money;
                    this.spawnMe(d.list[this.myId].carId);
                    Object.values(d.list).forEach(p => { if(p.id!==this.myId) this.spawnOther(p); });
                });
                this.socket.on('playerJoin', p => this.spawnOther(p));
                this.socket.on('countUpdate', c => document.getElementById('p-count').innerText = c);
                this.socket.on('playerUpdate', p => {
                    if(this.players[p.id]) {
                        const m = this.players[p.id].mesh;
                        m.position.lerp(new THREE.Vector3(p.x, p.y, p.z), 0.3);
                        m.quaternion.slerp(new THREE.Quaternion(p.qx, p.qy, p.qz, p.qw), 0.3);
                    }
                });
                this.socket.on('playerLeave', id => { if(this.players[id]) { this.scene.remove(this.players[id].mesh); delete this.players[id]; } });
                this.socket.on('serverMsg', msg => this.notify(msg));
                this.socket.on('economyUpdate', d => {
                    this.economy.money = d.money;
                    this.economy.owned = d.owned;
                    document.getElementById('cash').innerText = d.money;
                    if(d.car !== undefined) this.spawnMe(d.car);
                });
                this.socket.on('raceStart', () => {
                    this.racing = true;
                    this.myCar.lap = 1;
                    this.myCar.speed = 0;
                    // Grid Spawn Logic
                    const start = this.levelData.spawn;
                    this.myCar.pos.copy(start);
                    this.myCar.pos.y = 10;
                    // Look at next point
                    this.myCar.mesh.lookAt(this.levelData.checkpoints[1]);
                    this.myCar.quat.copy(this.myCar.mesh.quaternion);
                    
                    document.getElementById('join-btn').style.display = 'none';
                    document.getElementById('lap-counter').style.display = 'block';
                    this.notify("üü¢ GO!");
                });
            },

            spawnOther(p) {
                // Reuse CarFactory logic but simpler
                const mesh = CarFactory.create(p.color||0xffffff);
                mesh.position.set(p.x, p.y, p.z);
                this.scene.add(mesh);
                this.players[p.id] = {mesh:mesh};
            },

            setupInputs() {
                document.addEventListener('keydown', e => {
                    this.input[e.key] = true;
                    if(e.key === "Shift") this.input.Shift = true;
                });
                document.addEventListener('keyup', e => {
                    this.input[e.key] = false;
                    if(e.key === "Shift") this.input.Shift = false;
                    if(e.key.toLowerCase() === 'r') this.respawn();
                    if(e.key.toLowerCase() === 'c') this.camIndex = (this.camIndex + 1) % 3;
                });
            },

            respawn() {
                // Find nearest track point
                const cps = this.levelData.checkpoints;
                const idx = this.myCar.checkpoint; 
                const safe = cps[idx];
                this.myCar.pos.copy(safe);
                this.myCar.pos.y = 10;
                this.myCar.speed = 0;
                this.myCar.velocity.set(0,0,0);
                // Look at next
                this.myCar.mesh.lookAt(cps[(idx+1)%cps.length]);
                this.myCar.quat.copy(this.myCar.mesh.quaternion);
            },

            joinRace() { this.socket.emit('joinRace'); },

            checkLaps() {
                if(!this.racing) return;
                const cps = this.levelData.checkpoints;
                const nextIdx = (this.myCar.checkpoint + 1) % cps.length;
                const dist = this.myCar.pos.distanceTo(cps[nextIdx]);
                
                if(dist < 30) {
                    this.myCar.checkpoint = nextIdx;
                    // Lap
                    if(nextIdx === 0) {
                        this.myCar.lap++;
                        document.getElementById('lap-val').innerText = Math.min(this.myCar.lap, 5);
                        this.socket.emit('lapComplete', {lap: this.myCar.lap});
                        if(this.myCar.lap > 5) { this.racing = false; this.notify("FINISHED!"); }
                    }
                }
            },

            updateCam() {
                let offset;
                if(this.camIndex === 0) offset = new THREE.Vector3(0, 7, 16);
                else if(this.camIndex === 1) offset = new THREE.Vector3(0, 20, 35);
                else offset = new THREE.Vector3(0, 80, 0);
                offset.applyQuaternion(this.myCar.quat);
                const target = this.myCar.pos.clone().add(offset);
                this.camera.position.lerp(target, 0.1);
                this.camera.lookAt(this.myCar.pos);
            },

            drawMinimap() {
                const cvs = document.getElementById('minimap-canvas');
                const ctx = cvs.getContext('2d');
                ctx.clearRect(0,0,220,220);
                if(!this.myCar) return;
                
                ctx.save();
                ctx.translate(110, 110);
                // Rotate whole map opposite to player rotation to simulate "Map Rotating"
                const rot = new THREE.Euler().setFromQuaternion(this.myCar.quat).y;
                ctx.rotate(rot - Math.PI); // Rotate map
                
                const scale = 0.5;
                const px = this.myCar.pos.x;
                const pz = this.myCar.pos.z;

                // Draw Track
                const cps = this.levelData.checkpoints;
                ctx.strokeStyle = "#555"; ctx.lineWidth = 15; ctx.lineCap = "round";
                ctx.beginPath();
                cps.forEach((p, i) => {
                    const rx = (p.x - px) * scale;
                    const rz = (p.z - pz) * scale;
                    if(i===0) ctx.moveTo(rx, rz); else ctx.lineTo(rx, rz);
                });
                ctx.closePath(); ctx.stroke();
                
                // Track Highlight
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
                ctx.stroke();

                // Other Players
                Object.values(this.players).forEach(p => {
                    const m = p.mesh;
                    const rx = (m.position.x - px) * scale;
                    const rz = (m.position.z - pz) * scale;
                    ctx.fillStyle = "#ff0055";
                    ctx.beginPath(); ctx.arc(rx, rz, 5, 0, Math.PI*2); ctx.fill();
                });

                ctx.restore();

                // Draw Me (Fixed Center)
                ctx.fillStyle = "#00f3ff";
                ctx.beginPath(); ctx.arc(110, 110, 6, 0, Math.PI*2); ctx.fill();
                // Vision Cone
                ctx.beginPath(); ctx.moveTo(110,110);
                ctx.lineTo(100, 80); ctx.lineTo(120, 80);
                ctx.fillStyle = "rgba(0, 243, 255, 0.3)"; ctx.fill();
            },

            emitSmoke(pos) {
                if(!this.smoke) this.smoke = [];
                const g = new THREE.BoxGeometry(0.3,0.3,0.3);
                const m = new THREE.MeshBasicMaterial({color:0xaaaaaa, transparent:true, opacity:0.6});
                const mesh = new THREE.Mesh(g,m);
                mesh.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5),0,(Math.random()-0.5)));
                this.scene.add(mesh);
                this.smoke.push({m:mesh, life:1.0});
            },

            animate() {
                requestAnimationFrame(this.animate);
                if(this.myCar) {
                    const hFn = (x,z) => this.getTerrainHeight(x,z);
                    const onRoad = this.checkOffRoad();
                    this.myCar.update(this.input, 0.016, hFn, onRoad);
                    this.checkLaps();
                    this.updateCam();
                    this.audio.update(Math.abs(this.myCar.speed) / 2.5);
                    this.drawMinimap();
                    
                    document.getElementById('speed').innerText = Math.floor(Math.abs(this.myCar.speed) * 120);
                    document.getElementById('rpm').style.width = Math.min(100, Math.abs(this.myCar.speed)*60) + "%";

                    this.socket.emit('move', {
                        x: this.myCar.pos.x, y: this.myCar.pos.y, z: this.myCar.pos.z,
                        qx: this.myCar.quat.x, qy: this.myCar.quat.y, qz: this.myCar.quat.z, qw: this.myCar.quat.w
                    });
                }
                
                if(this.smoke) {
                    for(let i=this.smoke.length-1; i>=0; i--) {
                        let p = this.smoke[i];
                        p.life -= 0.03;
                        p.m.position.y += 0.05;
                        p.m.material.opacity = p.life * 0.5;
                        if(p.life <= 0) { this.scene.remove(p.m); this.smoke.splice(i,1); }
                    }
                }
                this.renderer.render(this.scene, this.camera);
            },

            notify(msg) {
                const d = document.createElement('div');
                d.className = 'msg'; d.innerText = msg;
                document.getElementById('msg-area').appendChild(d);
                setTimeout(() => d.remove(), 4000);
            },

            toggleShop() {
                const s = document.getElementById('shop');
                s.style.display = s.style.display==='flex'?'none':'flex';
                if(s.style.display==='flex') {
                    const g = document.getElementById('shop-grid');
                    g.innerHTML = '';
                    Object.values(this.shopData).forEach((item, id) => {
                        const div = document.createElement('div');
                        div.className = 'item';
                        const owned = this.economy.owned.includes(parseInt(id));
                        div.innerHTML = `<h3>${item.name}</h3><p>Price: $${item.price}</p><button onclick="Game.socket.emit('${owned?'equip':'buy'}', ${id})">${owned?'EQUIP':'BUY'}</button>`;
                        g.appendChild(div);
                    });
                }
            }
        };

        window.onload = () => Game.init();
    </script>
</body>
</html>
